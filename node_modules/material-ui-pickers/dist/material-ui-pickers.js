

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault(ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex.default : ex; }

let React = require('react');

let React__default = _interopDefault(React);
let PropTypes = _interopDefault(require('prop-types'));
let materialUi = require('material-ui');
let classnames = _interopDefault(require('classnames'));

let hookCallback;

function hooks() {
  return hookCallback(...arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback(callback) {
  hookCallback = callback;
}

function isArray(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
  // IE8 will treat undefined and null as object if it wasn't for
  // input != null
  return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
        return (Object.getOwnPropertyNames(obj).length === 0);
    } 
        var k;
        for (k in obj) {
            if (obj.hasOwnProperty(k)) {
                return false;
            }
        }
        return true;
    
}

function isUndefined(input) {
  return input === void 0;
}

function isNumber(input) {
  return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
  let res = [], 
i;
  for (i = 0; i < arr.length; ++i) {
    res.push(fn(arr[i], i));
  }
  return res;
}

function hasOwnProp(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
  for (let i in b) {
    if (hasOwnProp(b, i)) {
      a[i] = b[i];
    }
  }

  if (hasOwnProp(b, 'toString')) {
    a.toString = b.toString;
  }

  if (hasOwnProp(b, 'valueOf')) {
    a.valueOf = b.valueOf;
  }

  return a;
}

function createUTC(input, format, locale, strict) {
  return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
  // We need to deep clone this object.
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false,
  };
}

function getParsingFlags(m) {
  if (m._pf == null) {
    m._pf = defaultParsingFlags();
  }
  return m._pf;
}

let some;
if (Array.prototype.some) {
  some = Array.prototype.some;
} else {
  some = function (fun) {
    let t = Object(this);
    let len = t.length >>> 0;

    for (let i = 0; i < len; i++) {
      if (i in t && fun.call(this, t[i], i, t)) {
        return true;
      }
    }

    return false;
  };
}

function isValid(m) {
  if (m._isValid == null) {
    let flags = getParsingFlags(m);
    let parsedParts = some.call(flags.parsedDateParts, (i) => {
            return i != null;
        });
    let isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.weekdayMismatch &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

    if (m._strict) {
      isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
    }

    if (Object.isFrozen == null || !Object.isFrozen(m)) {
      m._isValid = isNowValid;
    } else {
      return isNowValid;
    }
  }
  return m._isValid;
}

function createInvalid(flags) {
  let m = createUTC(NaN);
  if (flags != null) {
    extend(getParsingFlags(m), flags);
  } else {
    getParsingFlags(m).userInvalidated = true;
  }

  return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
let momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
  let i, 
prop, 
val;

  if (!isUndefined(from._isAMomentObject)) {
    to._isAMomentObject = from._isAMomentObject;
  }
  if (!isUndefined(from._i)) {
    to._i = from._i;
  }
  if (!isUndefined(from._f)) {
    to._f = from._f;
  }
  if (!isUndefined(from._l)) {
    to._l = from._l;
  }
  if (!isUndefined(from._strict)) {
    to._strict = from._strict;
  }
  if (!isUndefined(from._tzm)) {
    to._tzm = from._tzm;
  }
  if (!isUndefined(from._isUTC)) {
    to._isUTC = from._isUTC;
  }
  if (!isUndefined(from._offset)) {
    to._offset = from._offset;
  }
  if (!isUndefined(from._pf)) {
    to._pf = getParsingFlags(from);
  }
  if (!isUndefined(from._locale)) {
    to._locale = from._locale;
  }

  if (momentProperties.length > 0) {
    for (i = 0; i < momentProperties.length; i++) {
      prop = momentProperties[i];
      val = from[prop];
      if (!isUndefined(val)) {
        to[prop] = val;
      }
    }
  }

  return to;
}

let updateInProgress = false;

// Moment prototype object
function Moment(config) {
  copyConfig(this, config);
  this._d = new Date(config._d != null ? config._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = new Date(NaN);
  }
  // Prevent infinite loop in case updateOffset creates new moment
  // objects.
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}

function isMoment(obj) {
  return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } 
        return Math.floor(number);
    
}

function toInt(argumentForCoercion) {
  let coercedNumber = +argumentForCoercion,
    value = 0;

  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }

  return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
  let len = Math.min(array1.length, array2.length),
    lengthDiff = Math.abs(array1.length - array2.length),
    diffs = 0,
    i;
  for (i = 0; i < len; i++) {
    if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}

function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !== 'undefined') && console.warn) {
    console.warn(`Deprecation warning: ${  msg}`);
  }
}

function deprecate(msg, fn) {
  let firstTime = true;

  return extend(function () {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      let args = [];
      let arg;
      for (let i = 0; i < arguments.length; i++) {
        arg = '';
        if (typeof arguments[i] === 'object') {
          arg += `\n[${  i  }] `;
          for (let key in arguments[0]) {
            arg += `${key  }: ${  arguments[0][key]  }, `;
          }
          arg = arg.slice(0, -2); // Remove trailing comma and space
        } else {
          arg = arguments[i];
        }
        args.push(arg);
      }
      warn(`${msg  }\nArguments: ${  Array.prototype.slice.call(args).join('')  }\n${  (new Error()).stack}`);
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}

let deprecations = {};

function deprecateSimple(name, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name, msg);
  }
  if (!deprecations[name]) {
    warn(msg);
    deprecations[name] = true;
  }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
  return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set(config) {
  let prop, 
i;
  for (i in config) {
    prop = config[i];
    if (isFunction(prop)) {
      this[i] = prop;
    } else {
      this[`_${  i}`] = prop;
    }
  }
  this._config = config;
  // Lenient ordinal parsing accepts just a number in addition to
  // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
  // TODO: Remove "ordinalParse" fallback in next major release.
  this._dayOfMonthOrdinalParseLenient = new RegExp(`${this._dayOfMonthOrdinalParse.source || this._ordinalParse.source 
            }|${  (/\d{1,2}/).source}`);
}

function mergeConfigs(parentConfig, childConfig) {
  let res = extend({}, parentConfig), 
prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
        res[prop] = {};
        extend(res[prop], parentConfig[prop]);
        extend(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
      // make sure changes to properties don't modify parent config
      res[prop] = extend({}, res[prop]);
    }
  }
  return res;
}

function Locale(config) {
  if (config != null) {
    this.set(config);
  }
}

let keys;

if (Object.keys) {
  keys = Object.keys;
} else {
  keys = function (obj) {
    let i, 
res = [];
    for (i in obj) {
      if (hasOwnProp(obj, i)) {
        res.push(i);
      }
    }
    return res;
  };
}

let defaultCalendar = {
  sameDay: '[Today at] LT',
  nextDay: '[Tomorrow at] LT',
  nextWeek: 'dddd [at] LT',
  lastDay: '[Yesterday at] LT',
  lastWeek: '[Last] dddd [at] LT',
  sameElse: 'L',
};

function calendar(key, mom, now) {
  let output = this._calendar[key] || this._calendar.sameElse;
  return isFunction(output) ? output.call(mom, now) : output;
}

let defaultLongDateFormat = {
  LTS: 'h:mm:ss A',
  LT: 'h:mm A',
  L: 'MM/DD/YYYY',
  LL: 'MMMM D, YYYY',
  LLL: 'MMMM D, YYYY h:mm A',
  LLLL: 'dddd, MMMM D, YYYY h:mm A',
};

function longDateFormat(key) {
  let format = this._longDateFormat[key],
    formatUpper = this._longDateFormat[key.toUpperCase()];

  if (format || !formatUpper) {
    return format;
  }

  this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, (val) => {
        return val.slice(1);
    });

  return this._longDateFormat[key];
}

let defaultInvalidDate = 'Invalid date';

function invalidDate() {
  return this._invalidDate;
}

let defaultOrdinal = '%d';
let defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal(number) {
  return this._ordinal.replace('%d', number);
}

let defaultRelativeTime = {
  future: 'in %s',
  past: '%s ago',
  s: 'a few seconds',
  ss: '%d seconds',
  m: 'a minute',
  mm: '%d minutes',
  h: 'an hour',
  hh: '%d hours',
  d: 'a day',
  dd: '%d days',
  M: 'a month',
  MM: '%d months',
  y: 'a year',
  yy: '%d years',
};

function relativeTime(number, withoutSuffix, string, isFuture) {
  let output = this._relativeTime[string];
  return (isFunction(output)) ?
    output(number, withoutSuffix, string, isFuture) :
    output.replace(/%d/i, number);
}

function pastFuture(diff, output) {
  let format = this._relativeTime[diff > 0 ? 'future' : 'past'];
  return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

let aliases = {};

function addUnitAlias(unit, shorthand) {
  let lowerCase = unit.toLowerCase();
  aliases[lowerCase] = aliases[`${lowerCase  }s`] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
  return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
  let normalizedInput = {},
    normalizedProp,
    prop;

  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }

  return normalizedInput;
}

let priorities = {};

function addUnitPriority(unit, priority) {
  priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
  let units = [];
  for (let u in unitsObj) {
    units.push({ unit: u, priority: priorities[u] });
  }
  units.sort((a, b) => {
        return a.priority - b.priority;
    });
  return units;
}

function zeroFill(number, targetLength, forceSign) {
  let absNumber = `${  Math.abs(number)}`,
    zerosToFill = targetLength - absNumber.length,
    sign = number >= 0;
  return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

let formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

let localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

let formatFunctions = {};

let formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken(token, padded, ordinal, callback) {
  let func = callback;
  if (typeof callback === 'string') {
    func = function () {
      return this[callback]();
    };
  }
  if (token) {
    formatTokenFunctions[token] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function () {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal) {
    formatTokenFunctions[ordinal] = function () {
      return this.localeData().ordinal(func.apply(this, arguments), token);
    };
  }
}

function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, '');
  }
  return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
  let array = format.match(formattingTokens), 
i, 
length;

  for (i = 0, length = array.length; i < length; i++) {
    if (formatTokenFunctions[array[i]]) {
      array[i] = formatTokenFunctions[array[i]];
    } else {
      array[i] = removeFormattingTokens(array[i]);
    }
  }

  return function (mom) {
    let output = '', 
i;
    for (i = 0; i < length; i++) {
      output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
    }
    return output;
  };
}

// format date using native date object
function formatMoment(m, format) {
  if (!m.isValid()) {
    return m.localeData().invalidDate();
  }

  format = expandFormat(format, m.localeData());
  formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

  return formatFunctions[format](m);
}

function expandFormat(format, locale) {
  let i = 5;

  function replaceLongDateFormatTokens(input) {
    return locale.longDateFormat(input) || input;
  }

  localFormattingTokens.lastIndex = 0;
  while (i >= 0 && localFormattingTokens.test(format)) {
    format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
    localFormattingTokens.lastIndex = 0;
    i -= 1;
  }

  return format;
}

let match1 = /\d/; //       0 - 9
let match2 = /\d\d/; //      00 - 99
let match3 = /\d{3}/; //     000 - 999
let match4 = /\d{4}/; //    0000 - 9999
let match6 = /[+-]?\d{6}/; // -999999 - 999999
let match1to2 = /\d\d?/; //       0 - 99
let match3to4 = /\d\d\d\d?/; //     999 - 9999
let match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999
let match1to3 = /\d{1,3}/; //       0 - 999
let match1to4 = /\d{1,4}/; //       0 - 9999
let match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

let matchUnsigned = /\d+/; //       0 - inf
let matchSigned = /[+-]?\d+/; //    -inf - inf

let matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
let matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

let matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
let matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


let regexes = {};

function addRegexToken(token, regex, strictRegex) {
  regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
    return (isStrict && strictRegex) ? strictRegex : regex;
  };
}

function getParseRegexForToken(token, config) {
  if (!hasOwnProp(regexes, token)) {
    return new RegExp(unescapeFormat(token));
  }

  return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
  return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, (matched, p1, p2, p3, p4) => {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

let tokens = {};

function addParseToken(token, callback) {
  let i, 
func = callback;
  if (typeof token === 'string') {
    token = [token];
  }
  if (isNumber(callback)) {
    func = function (input, array) {
      array[callback] = toInt(input);
    };
  }
  for (i = 0; i < token.length; i++) {
    tokens[token[i]] = func;
  }
}

function addWeekParseToken(token, callback) {
  addParseToken(token, (input, array, config, token) => {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
  if (input != null && hasOwnProp(tokens, token)) {
    tokens[token](input, config._a, config, token);
  }
}

let YEAR = 0;
let MONTH = 1;
let DATE = 2;
let HOUR = 3;
let MINUTE = 4;
let SECOND = 5;
let MILLISECOND = 6;
let WEEK = 7;
let WEEKDAY = 8;

// FORMATTING

addFormatToken('Y', 0, 0, function () {
  let y = this.year();
  return y <= 9999 ? `${  y}` : `+${  y}`;
});

addFormatToken(0, ['YY', 2], 0, function () {
  return this.year() % 100;
});

addFormatToken(0, ['YYYY', 4], 0, 'year');
addFormatToken(0, ['YYYYY', 5], 0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y', matchSigned);
addRegexToken('YY', match1to2, match2);
addRegexToken('YYYY', match1to4, match4);
addRegexToken('YYYYY', match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', (input, array) => {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', (input, array) => {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', (input, array) => {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
  return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
  return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

let getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear() {
  return isLeapYear(this.year());
}

function makeGetSet(unit, keepTime) {
  return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } 
            return get(this, unit);
        
    };
}

function get(mom, unit) {
  return mom.isValid() ?
    mom._d[`get${  mom._isUTC ? 'UTC' : ''  }${unit}`]() : NaN;
}

function set$1(mom, unit, value) {
  if (mom.isValid() && !isNaN(value)) {
    if (unit === 'FullYear' && isLeapYear(mom.year())) {
      mom._d[`set${  mom._isUTC ? 'UTC' : ''  }${unit}`](value, mom.month(), daysInMonth(value, mom.month()));
    } else {
      mom._d[`set${  mom._isUTC ? 'UTC' : ''  }${unit}`](value);
    }
  }
}

// MOMENTS

function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction(this[units])) {
    return this[units]();
  }
  return this;
}


function stringSet(units, value) {
  if (typeof units === 'object') {
    units = normalizeObjectUnits(units);
    let prioritized = getPrioritizedUnits(units);
    for (let i = 0; i < prioritized.length; i++) {
      this[prioritized[i].unit](units[prioritized[i].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units](value);
    }
  }
  return this;
}

function mod(n, x) {
  return ((n % x) + x) % x;
}

let indexOf;

if (Array.prototype.indexOf) {
  indexOf = Array.prototype.indexOf;
} else {
  indexOf = function (o) {
    // I know
    let i;
    for (i = 0; i < this.length; ++i) {
      if (this[i] === o) {
        return i;
      }
    }
    return -1;
  };
}

function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  let modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
  return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
  return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
  return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M', match1to2);
addRegexToken('MM', match1to2, match2);
addRegexToken('MMM', (isStrict, locale) => {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', (isStrict, locale) => {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], (input, array) => {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], (input, array, config, token) => {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

let MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
let defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths(m, format) {
  if (!m) {
    return isArray(this._months) ? this._months :
      this._months.standalone;
  }
  return isArray(this._months) ? this._months[m.month()] :
    this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

let defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort(m, format) {
  if (!m) {
    return isArray(this._monthsShort) ? this._monthsShort :
      this._monthsShort.standalone;
  }
  return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
    this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } 
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    
}

function localeMonthsParse(monthName, format, strict) {
  let i, 
mom, 
regex;

  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format, strict);
  }

  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }

  // TODO: add sorting
  // Sorting makes sure if one month (or abbr) is a prefix of another
  // see sorting in computeMonthsParse
  for (i = 0; i < 12; i++) {
    // make the regex if we don't have it already
    mom = createUTC([2000, i]);
    if (strict && !this._longMonthsParse[i]) {
      this._longMonthsParse[i] = new RegExp(`^${  this.months(mom, '').replace('.', '')  }$`, 'i');
      this._shortMonthsParse[i] = new RegExp(`^${  this.monthsShort(mom, '').replace('.', '')  }$`, 'i');
    }
    if (!strict && !this._monthsParse[i]) {
      regex = `^${  this.months(mom, '')  }|^${  this.monthsShort(mom, '')}`;
      this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
    }
    // test the regex
    if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
      return i;
    } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
      return i;
    } else if (!strict && this._monthsParse[i].test(monthName)) {
      return i;
    }
  }
}

// MOMENTS

function setMonth(mom, value) {
  let dayOfMonth;

  if (!mom.isValid()) {
    // No op
    return mom;
  }

  if (typeof value === 'string') {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      // TODO: Another silent failure?
      if (!isNumber(value)) {
        return mom;
      }
    }
  }

  dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
  mom._d[`set${  mom._isUTC ? 'UTC' : ''  }Month`](value, dayOfMonth);
  return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } 
        return get(this, 'Month');
    
}

function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}

let defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } 
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    
}

let defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } 
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    
}

function computeMonthsParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }

  let shortPieces = [], 
longPieces = [], 
mixedPieces = [],
    i, 
mom;
  for (i = 0; i < 12; i++) {
    // make the regex if we don't have it already
    mom = createUTC([2000, i]);
    shortPieces.push(this.monthsShort(mom, ''));
    longPieces.push(this.months(mom, ''));
    mixedPieces.push(this.months(mom, ''));
    mixedPieces.push(this.monthsShort(mom, ''));
  }
  // Sorting makes sure if one month (or abbr) is a prefix of another it
  // will match the longer piece.
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  for (i = 0; i < 12; i++) {
    shortPieces[i] = regexEscape(shortPieces[i]);
    longPieces[i] = regexEscape(longPieces[i]);
  }
  for (i = 0; i < 24; i++) {
    mixedPieces[i] = regexEscape(mixedPieces[i]);
  }

  this._monthsRegex = new RegExp(`^(${  mixedPieces.join('|')  })`, 'i');
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp(`^(${  longPieces.join('|')  })`, 'i');
  this._monthsShortStrictRegex = new RegExp(`^(${  shortPieces.join('|')  })`, 'i');
}

function createDate(y, m, d, h, M, s, ms) {
  // can't just apply() to create a date:
  // https://stackoverflow.com/q/181348
  let date = new Date(y, m, d, h, M, s, ms);

  // the date constructor remaps years 0-99 to 1900-1999
  if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
    date.setFullYear(y);
  }
  return date;
}

function createUTCDate(y) {
  let date = new Date(Date.UTC.apply(null, arguments));

  // the Date.UTC function remaps years 0-99 to 1900-1999
  if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
    date.setUTCFullYear(y);
  }
  return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
  let // first-week day -- which january is always in the first week (4 for iso, 1 for other)
    fwd = 7 + dow - doy,
    // first-week day local weekday -- which local weekday is fwd
    fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

  return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  let localWeekday = (7 + weekday - dow) % 7,
    weekOffset = firstWeekOffset(year, dow, doy),
    dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
    resYear, 
resDayOfYear;

  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }

  return {
    year: resYear,
    dayOfYear: resDayOfYear,
  };
}

function weekOfYear(mom, dow, doy) {
  let weekOffset = firstWeekOffset(mom.year(), dow, doy),
    week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
    resWeek, 
resYear;

  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }

  return {
    week: resWeek,
    year: resYear,
  };
}

function weeksInYear(year, dow, doy) {
  let weekOffset = firstWeekOffset(year, dow, doy),
    weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w', match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W', match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], (input, week, config, token) => {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

let defaultLocaleWeek = {
  dow: 0, // Sunday is the first day of the week.
  doy: 6, // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek() {
  return this._week.dow;
}

function localeFirstDayOfYear() {
  return this._week.doy;
}

// MOMENTS

function getSetWeek(input) {
  let week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek(input) {
  let week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
  return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
  return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
  return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d', match1to2);
addRegexToken('e', match1to2);
addRegexToken('E', match1to2);
addRegexToken('dd', (isStrict, locale) => {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd', (isStrict, locale) => {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd', (isStrict, locale) => {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], (input, week, config, token) => {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], (input, week, config, token) => {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
  if (typeof input !== 'string') {
    return input;
  }

  if (!isNaN(input)) {
    return parseInt(input, 10);
  }

  input = locale.weekdaysParse(input);
  if (typeof input === 'number') {
    return input;
  }

  return null;
}

function parseIsoWeekday(input, locale) {
  if (typeof input === 'string') {
    return locale.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}

// LOCALES

let defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays(m, format) {
  if (!m) {
    return isArray(this._weekdays) ? this._weekdays :
      this._weekdays.standalone;
  }
  return isArray(this._weekdays) ? this._weekdays[m.day()] :
    this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

let defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort(m) {
  return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

let defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin(m) {
  return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } 
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        
    }
}

function localeWeekdaysParse(weekdayName, format, strict) {
  let i, 
mom, 
regex;

  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format, strict);
  }

  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }

  for (i = 0; i < 7; i++) {
    // make the regex if we don't have it already

    mom = createUTC([2000, 1]).day(i);
    if (strict && !this._fullWeekdaysParse[i]) {
      this._fullWeekdaysParse[i] = new RegExp(`^${  this.weekdays(mom, '').replace('.', '\.?')  }$`, 'i');
      this._shortWeekdaysParse[i] = new RegExp(`^${  this.weekdaysShort(mom, '').replace('.', '\.?')  }$`, 'i');
      this._minWeekdaysParse[i] = new RegExp(`^${  this.weekdaysMin(mom, '').replace('.', '\.?')  }$`, 'i');
    }
    if (!this._weekdaysParse[i]) {
      regex = `^${  this.weekdays(mom, '')  }|^${  this.weekdaysShort(mom, '')  }|^${  this.weekdaysMin(mom, '')}`;
      this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
    }
    // test the regex
    if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
      return i;
    }
  }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } 
        return day;
    
}

function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  let weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } 
        return this.day() || 7;
    
}

let defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } 
            return this._weekdaysRegex;
        
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

let defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } 
            return this._weekdaysShortRegex;
        
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

let defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } 
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    
}


function computeWeekdaysParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }

  let minPieces = [], 
shortPieces = [], 
longPieces = [], 
mixedPieces = [],
    i, 
mom, 
minp, 
shortp, 
longp;
  for (i = 0; i < 7; i++) {
    // make the regex if we don't have it already
    mom = createUTC([2000, 1]).day(i);
    minp = this.weekdaysMin(mom, '');
    shortp = this.weekdaysShort(mom, '');
    longp = this.weekdays(mom, '');
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  // Sorting makes sure if one weekday (or abbr) is a prefix of another it
  // will match the longer piece.
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  for (i = 0; i < 7; i++) {
    shortPieces[i] = regexEscape(shortPieces[i]);
    longPieces[i] = regexEscape(longPieces[i]);
    mixedPieces[i] = regexEscape(mixedPieces[i]);
  }

  this._weekdaysRegex = new RegExp(`^(${  mixedPieces.join('|')  })`, 'i');
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;

  this._weekdaysStrictRegex = new RegExp(`^(${  longPieces.join('|')  })`, 'i');
  this._weekdaysShortStrictRegex = new RegExp(`^(${  shortPieces.join('|')  })`, 'i');
  this._weekdaysMinStrictRegex = new RegExp(`^(${  minPieces.join('|')  })`, 'i');
}

// FORMATTING

function hFormat() {
  return this.hours() % 12 || 12;
}

function kFormat() {
  return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
  return `${  hFormat.apply(this)  }${zeroFill(this.minutes(), 2)}`;
});

addFormatToken('hmmss', 0, 0, function () {
  return `${  hFormat.apply(this)  }${zeroFill(this.minutes(), 2) 
        }${zeroFill(this.seconds(), 2)}`;
});

addFormatToken('Hmm', 0, 0, function () {
  return `${  this.hours()  }${zeroFill(this.minutes(), 2)}`;
});

addFormatToken('Hmmss', 0, 0, function () {
  return `${  this.hours()  }${zeroFill(this.minutes(), 2) 
        }${zeroFill(this.seconds(), 2)}`;
});

function meridiem(token, lowercase) {
  addFormatToken(token, 0, 0, function () {
    return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
  });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem(isStrict, locale) {
  return locale._meridiemParse;
}

addRegexToken('a', matchMeridiem);
addRegexToken('A', matchMeridiem);
addRegexToken('H', match1to2);
addRegexToken('h', match1to2);
addRegexToken('k', match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], (input, array, config) => {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], (input, array, config) => {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], (input, array, config) => {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', (input, array, config) => {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', (input, array, config) => {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', (input, array, config) => {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', (input, array, config) => {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM(input) {
  // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
  // Using charAt should be more compatible.
  return ((`${input  }`).toLowerCase().charAt(0) === 'p');
}

let defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } 
        return isLower ? 'am' : 'AM';
    
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
let getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
let baseConfig = {
  calendar: defaultCalendar,
  longDateFormat: defaultLongDateFormat,
  invalidDate: defaultInvalidDate,
  ordinal: defaultOrdinal,
  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
  relativeTime: defaultRelativeTime,

  months: defaultLocaleMonths,
  monthsShort: defaultLocaleMonthsShort,

  week: defaultLocaleWeek,

  weekdays: defaultLocaleWeekdays,
  weekdaysMin: defaultLocaleWeekdaysMin,
  weekdaysShort: defaultLocaleWeekdaysShort,

  meridiemParse: defaultLocaleMeridiemParse,
};

// internal storage for locale config files
let locales = {};
let localeFamilies = {};
let globalLocale;

function normalizeLocale(key) {
  return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
  let i = 0, 
j, 
next, 
locale, 
split;

  while (i < names.length) {
    split = normalizeLocale(names[i]).split('-');
    j = split.length;
    next = normalizeLocale(names[i + 1]);
    next = next ? next.split('-') : null;
    while (j > 0) {
      locale = loadLocale(split.slice(0, j).join('-'));
      if (locale) {
        return locale;
      }
      if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
        // the next array item is better than a shallower substring of this one
        break;
      }
      j--;
    }
    i++;
  }
  return null;
}

function loadLocale(name) {
  let oldLocale = null;
  // TODO: Find a better way to register and load all the locales in Node
  if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
    try {
      oldLocale = globalLocale._abbr;
      let aliasedRequire = require;
      aliasedRequire(`./locale/${  name}`);
      getSetGlobalLocale(oldLocale);
    } catch (e) {}
  }
  return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale(key, values) {
  let data;
  if (key) {
    if (isUndefined(values)) {
      data = getLocale(key);
    } else {
      data = defineLocale(key, values);
    }

    if (data) {
      // moment.duration._locale = moment._locale = data;
      globalLocale = data;
    }
  }

  return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } 
        // useful for testing
        delete locales[name];
        return null;
    
}

function updateLocale(name, config) {
  if (config != null) {
    let locale, 
parentConfig = baseConfig;
    // MERGE
    if (locales[name] != null) {
      parentConfig = locales[name]._config;
    }
    config = mergeConfigs(parentConfig, config);
    locale = new Locale(config);
    locale.parentLocale = locales[name];
    locales[name] = locale;

    // backwards compat for now: also set the locale
    getSetGlobalLocale(name);
  } else {
    // pass null for config to unupdate, useful for tests
    if (locales[name] != null) {
      if (locales[name].parentLocale != null) {
        locales[name] = locales[name].parentLocale;
      } else if (locales[name] != null) {
        delete locales[name];
      }
    }
  }
  return locales[name];
}

// returns locale data
function getLocale(key) {
  let locale;

  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }

  if (!key) {
    return globalLocale;
  }

  if (!isArray(key)) {
    // short-circuit everything else
    locale = loadLocale(key);
    if (locale) {
      return locale;
    }
    key = [key];
  }

  return chooseLocale(key);
}

function listLocales() {
  return keys(locales);
}

function checkOverflow(m) {
  let overflow;
  let a = m._a;

  if (a && getParsingFlags(m).overflow === -2) {
    overflow =
            a[MONTH] < 0 || a[MONTH] > 11 ? MONTH :
              a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                  a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE :
                    a[SECOND] < 0 || a[SECOND] > 59 ? SECOND :
                      a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                        -1;

    if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }

    getParsingFlags(m).overflow = overflow;
  }

  return m;
}

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
  if (a != null) {
    return a;
  }
  if (b != null) {
    return b;
  }
  return c;
}

function currentDateArray(config) {
  // hooks is actually the exported moment object
  let nowValue = new Date(hooks.now());
  if (config._useUTC) {
    return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray(config) {
  let i, 
date, 
input = [], 
currentDate, 
yearToUse;

  if (config._d) {
    return;
  }

  currentDate = currentDateArray(config);

  // compute day of the year from weeks and weekdays
  if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config);
  }

  // if the day of the year is set, figure out what it is
  if (config._dayOfYear != null) {
    yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

    if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
      getParsingFlags(config)._overflowDayOfYear = true;
    }

    date = createUTCDate(yearToUse, 0, config._dayOfYear);
    config._a[MONTH] = date.getUTCMonth();
    config._a[DATE] = date.getUTCDate();
  }

  // Default to current date.
  // * if no year, month, day of month are given, default to today
  // * if day of month is given, default month and year
  // * if month is given, default only year
  // * if year is given, don't default anything
  for (i = 0; i < 3 && config._a[i] == null; ++i) {
    config._a[i] = input[i] = currentDate[i];
  }

  // Zero out whatever was not defaulted, including time
  for (; i < 7; i++) {
    config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
  }

  // Check for 24:00:00.000
  if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
    config._nextDay = true;
    config._a[HOUR] = 0;
  }

  config._d = (config._useUTC ? createUTCDate : createDate)(...input);
  // Apply timezone offset from input. The actual utcOffset can be changed
  // with parseZone.
  if (config._tzm != null) {
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
  }

  if (config._nextDay) {
    config._a[HOUR] = 24;
  }

  // check for mismatching day of week
  if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== config._d.getDay()) {
    getParsingFlags(config).weekdayMismatch = true;
  }
}

function dayOfYearFromWeekInfo(config) {
  let w, 
weekYear, 
week, 
weekday, 
dow, 
doy, 
temp, 
weekdayOverflow;

  w = config._w;
  if (w.GG != null || w.W != null || w.E != null) {
    dow = 1;
    doy = 4;

    // TODO: We need to take the current isoWeekYear, but that depends on
    // how we interpret now (local, utc, fixed offset). So create
    // a now version of current config (take local/utc/offset flags, and
    // create now).
    weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
    week = defaults(w.W, 1);
    weekday = defaults(w.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config._locale._week.dow;
    doy = config._locale._week.doy;

    let curWeek = weekOfYear(createLocal(), dow, doy);

    weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

    // Default to current week.
    week = defaults(w.w, curWeek.week);

    if (w.d != null) {
      // weekday -- low day numbers are considered next week
      weekday = w.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w.e != null) {
      // local weekday -- counting starts from begining of week
      weekday = w.e + dow;
      if (w.e < 0 || w.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      // default to begining of week
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config._a[YEAR] = temp.year;
    config._dayOfYear = temp.dayOfYear;
  }
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
let extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
let basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

let tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

let isoDates = [
  ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
  ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
  ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
  ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
  ['YYYY-DDD', /\d{4}-\d{3}/],
  ['YYYY-MM', /\d{4}-\d\d/, false],
  ['YYYYYYMMDD', /[+-]\d{10}/],
  ['YYYYMMDD', /\d{8}/],
  // YYYYMM is NOT allowed by the standard
  ['GGGG[W]WWE', /\d{4}W\d{3}/],
  ['GGGG[W]WW', /\d{4}W\d{2}/, false],
  ['YYYYDDD', /\d{7}/],
];

// iso time formats and regexes
let isoTimes = [
  ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
  ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
  ['HH:mm:ss', /\d\d:\d\d:\d\d/],
  ['HH:mm', /\d\d:\d\d/],
  ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
  ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
  ['HHmmss', /\d\d\d\d\d\d/],
  ['HHmm', /\d\d\d\d/],
  ['HH', /\d\d/],
];

let aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
  let i, 
l,
    string = config._i,
    match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
    allowTime, 
dateFormat, 
timeFormat, 
tzFormat;

  if (match) {
    getParsingFlags(config).iso = true;

    for (i = 0, l = isoDates.length; i < l; i++) {
      if (isoDates[i][1].exec(match[1])) {
        dateFormat = isoDates[i][0];
        allowTime = isoDates[i][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config._isValid = false;
      return;
    }
    if (match[3]) {
      for (i = 0, l = isoTimes.length; i < l; i++) {
        if (isoTimes[i][1].exec(match[3])) {
          // match[2] should be 'T' or space
          timeFormat = (match[2] || ' ') + isoTimes[i][0];
          break;
        }
      }
      if (timeFormat == null) {
        config._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config._isValid = false;
      return;
    }
    if (match[4]) {
      if (tzRegex.exec(match[4])) {
        tzFormat = 'Z';
      } else {
        config._isValid = false;
        return;
      }
    }
    config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
    configFromStringAndFormat(config);
  } else {
    config._isValid = false;
  }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
let rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  let result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10),
  ];

  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }

  return result;
}

function untruncateYear(yearStr) {
  let year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2000 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}

function preprocessRFC2822(s) {
  // Remove comments and folding whitespace and replace multiple-spaces with a single space
  return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').trim();
}

function checkWeekday(weekdayStr, parsedInput, config) {
  if (weekdayStr) {
    // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
    let weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
      weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config).weekdayMismatch = true;
      config._isValid = false;
      return false;
    }
  }
  return true;
}

let obsOffsets = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60,
};

function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
        return obsOffsets[obsOffset];
    } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
    } 
        var hm = parseInt(numOffset, 10);
        var m = hm % 100, h = (hm - m) / 100;
        return h * 60 + m;
    
}

// date and time from ref 2822 format
function configFromRFC2822(config) {
  let match = rfc2822.exec(preprocessRFC2822(config._i));
  if (match) {
    let parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
    if (!checkWeekday(match[1], parsedArray, config)) {
      return;
    }

    config._a = parsedArray;
    config._tzm = calculateOffset(match[8], match[9], match[10]);

    config._d = createUTCDate(...config._a);
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

    getParsingFlags(config).rfc2822 = true;
  } else {
    config._isValid = false;
  }
}

// date from iso format or fallback
function configFromString(config) {
  let matched = aspNetJsonRegex.exec(config._i);

  if (matched !== null) {
    config._d = new Date(+matched[1]);
    return;
  }

  configFromISO(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }

  configFromRFC2822(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }

  // Final attempt, use Input Fallback
  hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
  'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
  (config) => {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    },
);

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
  // TODO: Move this to another part of the creation flow to prevent circular deps
  if (config._f === hooks.ISO_8601) {
    configFromISO(config);
    return;
  }
  if (config._f === hooks.RFC_2822) {
    configFromRFC2822(config);
    return;
  }
  config._a = [];
  getParsingFlags(config).empty = true;

  // This array is used to make a Date, either with `new Date` or `Date.UTC`
  let string = `${  config._i}`,
    i, 
parsedInput, 
tokens, 
token, 
skipped,
    stringLength = string.length,
    totalParsedInputLength = 0;

  tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];
    parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
    // console.log('token', token, 'parsedInput', parsedInput,
    //         'regex', getParseRegexForToken(token, config));
    if (parsedInput) {
      skipped = string.substr(0, string.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config).unusedInput.push(skipped);
      }
      string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
      totalParsedInputLength += parsedInput.length;
    }
    // don't parse if it's not a known token
    if (formatTokenFunctions[token]) {
      if (parsedInput) {
        getParsingFlags(config).empty = false;
      } else {
        getParsingFlags(config).unusedTokens.push(token);
      }
      addTimeToArrayFromToken(token, parsedInput, config);
    } else if (config._strict && !parsedInput) {
      getParsingFlags(config).unusedTokens.push(token);
    }
  }

  // add remaining unparsed input length to the string
  getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
  if (string.length > 0) {
    getParsingFlags(config).unusedInput.push(string);
  }

  // clear _12h flag if hour is <= 12
  if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
    getParsingFlags(config).bigHour = undefined;
  }

  getParsingFlags(config).parsedDateParts = config._a.slice(0);
  getParsingFlags(config).meridiem = config._meridiem;
  // handle meridiem
  config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

  configFromArray(config);
  checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } 
        // this is not supposed to happen
        return hour;
    
}

// date from string and array of format strings
function configFromStringAndArray(config) {
  let tempConfig,
    bestMoment,

    scoreToBeat,
    i,
    currentScore;

  if (config._f.length === 0) {
    getParsingFlags(config).invalidFormat = true;
    config._d = new Date(NaN);
    return;
  }

  for (i = 0; i < config._f.length; i++) {
    currentScore = 0;
    tempConfig = copyConfig({}, config);
    if (config._useUTC != null) {
      tempConfig._useUTC = config._useUTC;
    }
    tempConfig._f = config._f[i];
    configFromStringAndFormat(tempConfig);

    if (!isValid(tempConfig)) {
      continue;
    }

    // if there is any input that was not parsed add a penalty for that format
    currentScore += getParsingFlags(tempConfig).charsLeftOver;

    // or tokens
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

    getParsingFlags(tempConfig).score = currentScore;

    if (scoreToBeat == null || currentScore < scoreToBeat) {
      scoreToBeat = currentScore;
      bestMoment = tempConfig;
    }
  }

  extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
  if (config._d) {
    return;
  }

  let i = normalizeObjectUnits(config._i);
  config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], (obj) => {
        return obj && parseInt(obj, 10);
    });

  configFromArray(config);
}

function createFromConfig(config) {
  let res = new Moment(checkOverflow(prepareConfig(config)));
  if (res._nextDay) {
    // Adding is smart enough around DST
    res.add(1, 'd');
    res._nextDay = undefined;
  }

  return res;
}

function prepareConfig(config) {
  let input = config._i,
    format = config._f;

  config._locale = config._locale || getLocale(config._l);

  if (input === null || (format === undefined && input === '')) {
    return createInvalid({ nullInput: true });
  }

  if (typeof input === 'string') {
    config._i = input = config._locale.preparse(input);
  }

  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate(input)) {
    config._d = input;
  } else if (isArray(format)) {
    configFromStringAndArray(config);
  } else if (format) {
    configFromStringAndFormat(config);
  } else {
    configFromInput(config);
  }

  if (!isValid(config)) {
    config._d = null;
  }

  return config;
}

function configFromInput(config) {
  let input = config._i;
  if (isUndefined(input)) {
    config._d = new Date(hooks.now());
  } else if (isDate(input)) {
    config._d = new Date(input.valueOf());
  } else if (typeof input === 'string') {
    configFromString(config);
  } else if (isArray(input)) {
    config._a = map(input.slice(0), (obj) => {
            return parseInt(obj, 10);
        });
    configFromArray(config);
  } else if (isObject(input)) {
    configFromObject(config);
  } else if (isNumber(input)) {
    // from milliseconds
    config._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config);
  }
}

function createLocalOrUTC(input, format, locale, strict, isUTC) {
  let c = {};

  if (locale === true || locale === false) {
    strict = locale;
    locale = undefined;
  }

  if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
    input = undefined;
  }
  // object construction must be done this way.
  // https://github.com/moment/moment/issues/1423
  c._isAMomentObject = true;
  c._useUTC = c._isUTC = isUTC;
  c._l = locale;
  c._i = input;
  c._f = format;
  c._strict = strict;

  return createFromConfig(c);
}

function createLocal(input, format, locale, strict) {
  return createLocalOrUTC(input, format, locale, strict, false);
}

let prototypeMin = deprecate(
  'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
  function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } 
            return createInvalid();
        
    },
);

let prototypeMax = deprecate(
  'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
  function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } 
            return createInvalid();
        
    },
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
  let res, 
i;
  if (moments.length === 1 && isArray(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i = 1; i < moments.length; ++i) {
    if (!moments[i].isValid() || moments[i][fn](res)) {
      res = moments[i];
    }
  }
  return res;
}

// TODO: Use [].sort instead?
function min() {
  let args = [].slice.call(arguments, 0);

  return pickBy('isBefore', args);
}

function max() {
  let args = [].slice.call(arguments, 0);

  return pickBy('isAfter', args);
}

let now = function () {
  return Date.now ? Date.now() : +(new Date());
};

let ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
  for (let key in m) {
    if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
      return false;
    }
  }

  let unitHasDecimal = false;
  for (let i = 0; i < ordering.length; ++i) {
    if (m[ordering[i]]) {
      if (unitHasDecimal) {
        return false; // only allow non-integers for smallest unit
      }
      if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
        unitHasDecimal = true;
      }
    }
  }

  return true;
}

function isValid$1() {
  return this._isValid;
}

function createInvalid$1() {
  return createDuration(NaN);
}

function Duration(duration) {
  let normalizedInput = normalizeObjectUnits(duration),
    years = normalizedInput.year || 0,
    quarters = normalizedInput.quarter || 0,
    months = normalizedInput.month || 0,
    weeks = normalizedInput.week || 0,
    days = normalizedInput.day || 0,
    hours = normalizedInput.hour || 0,
    minutes = normalizedInput.minute || 0,
    seconds = normalizedInput.second || 0,
    milliseconds = normalizedInput.millisecond || 0;

  this._isValid = isDurationValid(normalizedInput);

  // representation for dateAddRemove
  this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; // using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
  // Because of dateAddRemove treats 24 hours as different from a
  // day when working around DST, we need to store them separately
  this._days = +days +
        weeks * 7;
  // It is impossible to translate months into days without knowing
  // which months you are are talking about, so we have to store
  // it separately.
  this._months = +months +
        quarters * 3 +
        years * 12;

  this._data = {};

  this._locale = getLocale();

  this._bubble();
}

function isDuration(obj) {
  return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } 
        return Math.round(number);
    
}

// FORMATTING

function offset(token, separator) {
  addFormatToken(token, 0, 0, function () {
    let offset = this.utcOffset();
    let sign = '+';
    if (offset < 0) {
      offset = -offset;
      sign = '-';
    }
    return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
  });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z', matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], (input, array, config) => {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
let chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
  let matches = (string || '').match(matcher);

  if (matches === null) {
    return null;
  }

  let chunk = matches[matches.length - 1] || [];
  let parts = (`${chunk  }`).match(chunkOffset) || ['-', 0, 0];
  let minutes = +(parts[1] * 60) + toInt(parts[2]);

  return minutes === 0 ?
    0 :
    parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } 
        return createLocal(input).local();
    
}

function getDateOffset(m) {
  // On Firefox.24 Date#getTimezoneOffset returns a floating point.
  // https://github.com/moment/moment/pull/1871
  return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } 
        return this._isUTC ? offset : getDateOffset(this);
    
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } 
        return -this.utcOffset();
    
}

function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;

    if (keepLocalTime) {
      this.subtract(getDateOffset(this), 'm');
    }
  }
  return this;
}

function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === 'string') {
    let tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}

function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;

  return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime() {
  return (
    this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
  );
}

function isDaylightSavingTimeShifted() {
  if (!isUndefined(this._isDSTShifted)) {
    return this._isDSTShifted;
  }

  let c = {};

  copyConfig(c, this);
  c = prepareConfig(c);

  if (c._a) {
    let other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
    this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }

  return this._isDSTShifted;
}

function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}

function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
let aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
let isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

function createDuration(input, key) {
  let duration = input,
    // matching against regexp is expensive, do it on demand
    match = null,
    sign,
    ret,
    diffRes;

  if (isDuration(input)) {
    duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months,
    };
  } else if (isNumber(input)) {
    duration = {};
    if (key) {
      duration[key] = input;
    } else {
      duration.milliseconds = input;
    }
  } else if (match = aspNetRegex.exec(input)) {
    sign = (match[1] === '-') ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match[DATE]) * sign,
      h: toInt(match[HOUR]) * sign,
      m: toInt(match[MINUTE]) * sign,
      s: toInt(match[SECOND]) * sign,
      ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
    };
  } else if (match = isoRegex.exec(input)) {
    sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
    duration = {
      y: parseIso(match[2], sign),
      M: parseIso(match[3], sign),
      w: parseIso(match[4], sign),
      d: parseIso(match[5], sign),
      h: parseIso(match[6], sign),
      m: parseIso(match[7], sign),
      s: parseIso(match[8], sign),
    };
  } else if (duration == null) { // checks for null or undefined
    duration = {};
  } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
    diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }

  ret = new Duration(duration);

  if (isDuration(input) && hasOwnProp(input, '_locale')) {
    ret._locale = input._locale;
  }

  return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso(inp, sign) {
  // We'd normally use ~~inp for this, but unfortunately it also
  // converts floats to ints.
  // inp may be undefined, so careful calling replace on it.
  let res = inp && parseFloat(inp.replace(',', '.'));
  // apply sign while we're at it
  return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
  let res = { milliseconds: 0, months: 0 };

  res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, 'M').isAfter(other)) {
    --res.months;
  }

  res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

  return res;
}

function momentsDifference(base, other) {
  let res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }

  other = cloneWithOffset(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference(base, other);
  } else {
    res = positiveMomentsDifference(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }

  return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
  return function (val, period) {
    let dur, 
tmp;
    // invert the arguments, but complain about it
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(name, `moment().${  name   }(period, number) is deprecated. Please use moment().${  name  }(number, period). ` +
            `See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.`);
      tmp = val; val = period; period = tmp;
    }

    val = typeof val === 'string' ? +val : val;
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}

function addSubtract(mom, duration, isAdding, updateOffset) {
  let milliseconds = duration._milliseconds,
    days = absRound(duration._days),
    months = absRound(duration._months);

  if (!mom.isValid()) {
    // No op
    return;
  }

  updateOffset = updateOffset == null ? true : updateOffset;

  if (months) {
    setMonth(mom, get(mom, 'Month') + months * isAdding);
  }
  if (days) {
    set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
  }
  if (milliseconds) {
    mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days || months);
  }
}

let add = createAdder(1, 'add');
let subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
  let diff = myMoment.diff(now, 'days', true);
  return diff < -6 ? 'sameElse' :
    diff < -1 ? 'lastWeek' :
      diff < 0 ? 'lastDay' :
        diff < 1 ? 'sameDay' :
          diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1(time, formats) {
  // We want to compare the start of today, vs this.
  // Getting start-of-today depends on whether we're local/utc/offset or not.
  let now = time || createLocal(),
    sod = cloneWithOffset(now, this).startOf('day'),
    format = hooks.calendarFormat(this, sod) || 'sameElse';

  let output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

  return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone() {
  return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } 
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } 
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    
}

function isBetween(from, to, units, inclusivity) {
  inclusivity = inclusivity || '()';
  return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } 
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    
}

function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}

function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}

function diff(input, units, asFloat) {
  let that,
    zoneDelta,
    delta, 
output;

  if (!this.isValid()) {
    return NaN;
  }

  that = cloneWithOffset(input, this);

  if (!that.isValid()) {
    return NaN;
  }

  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

  units = normalizeUnits(units);

  switch (units) {
    case 'year': output = monthDiff(this, that) / 12; break;
    case 'month': output = monthDiff(this, that); break;
    case 'quarter': output = monthDiff(this, that) / 3; break;
    case 'second': output = (this - that) / 1e3; break; // 1000
    case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
    case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
    case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
    case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
    default: output = this - that;
  }

  return asFloat ? output : absFloor(output);
}

function monthDiff(a, b) {
  // difference in months
  let wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
    // b is in (anchor - 1 month, anchor + 1 month)
    anchor = a.clone().add(wholeMonthDiff, 'months'),
    anchor2, 
adjust;

  if (b - anchor < 0) {
    anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
    // linear across the month
    adjust = (b - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
    // linear across the month
    adjust = (b - anchor) / (anchor2 - anchor);
  }

  // check for negative zero, return zero if negative zero
  return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString() {
  return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString() {
  if (!this.isValid()) {
    return null;
  }
  let m = this.clone().utc();
  if (m.year() < 0 || m.year() > 9999) {
    return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
  }
  if (isFunction(Date.prototype.toISOString)) {
    // native implementation is ~50x faster, use it when we can
    return this.toDate().toISOString();
  }
  return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect() {
  if (!this.isValid()) {
    return `moment.invalid(/* ${  this._i  } */)`;
  }
  let func = 'moment';
  let zone = '';
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
    zone = 'Z';
  }
  let prefix = `[${  func  }("]`;
  let year = (this.year() >= 0 && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
  let datetime = '-MM-DD[T]HH:mm:ss.SSS';
  let suffix = `${zone  }[")]`;

  return this.format(prefix + year + datetime + suffix);
}

function format(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  let output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } 
        return this.localeData().invalidDate();
    
}

function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } 
        return this.localeData().invalidDate();
    
}

function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } 
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    
}

let lang = deprecate(
  'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
  function (key) {
        if (key === undefined) {
            return this.localeData();
        } 
            return this.locale(key);
        
    },
);

function localeData() {
  return this._locale;
}

function startOf(units) {
  units = normalizeUnits(units);
  // the following switch intentionally omits break keywords
  // to utilize falling through the cases.
  switch (units) {
    case 'year':
      this.month(0);
      /* falls through */
    case 'quarter':
    case 'month':
      this.date(1);
      /* falls through */
    case 'week':
    case 'isoWeek':
    case 'day':
    case 'date':
      this.hours(0);
      /* falls through */
    case 'hour':
      this.minutes(0);
      /* falls through */
    case 'minute':
      this.seconds(0);
      /* falls through */
    case 'second':
      this.milliseconds(0);
  }

  // weeks are a special case
  if (units === 'week') {
    this.weekday(0);
  }
  if (units === 'isoWeek') {
    this.isoWeekday(1);
  }

  // quarters are also special
  if (units === 'quarter') {
    this.month(Math.floor(this.month() / 3) * 3);
  }

  return this;
}

function endOf(units) {
  units = normalizeUnits(units);
  if (units === undefined || units === 'millisecond') {
    return this;
  }

  // 'date' is an alias for 'day', so it should be considered as such.
  if (units === 'date') {
    units = 'day';
  }

  return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf() {
  return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix() {
  return Math.floor(this.valueOf() / 1000);
}

function toDate() {
  return new Date(this.valueOf());
}

function toArray() {
  let m = this;
  return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject() {
  let m = this;
  return {
    years: m.year(),
    months: m.month(),
    date: m.date(),
    hours: m.hours(),
    minutes: m.minutes(),
    seconds: m.seconds(),
    milliseconds: m.milliseconds(),
  };
}

function toJSON() {
  // new Date(NaN).toJSON() === null
  return this.isValid() ? this.toISOString() : null;
}

function isValid$2() {
  return isValid(this);
}

function parsingFlags() {
  return extend({}, getParsingFlags(this));
}

function invalidAt() {
  return getParsingFlags(this).overflow;
}

function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict,
  };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
  return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
  return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken(token, getter) {
  addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg', 'weekYear');
addWeekYearFormatToken('ggggg', 'weekYear');
addWeekYearFormatToken('GGGG', 'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G', matchSigned);
addRegexToken('g', matchSigned);
addRegexToken('GG', match1to2, match2);
addRegexToken('gg', match1to2, match2);
addRegexToken('GGGG', match1to4, match4);
addRegexToken('gggg', match1to4, match4);
addRegexToken('GGGGG', match1to6, match6);
addRegexToken('ggggg', match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], (input, week, config, token) => {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], (input, week, config, token) => {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(
this,
    input,
    this.week(),
    this.weekday(),
    this.localeData()._week.dow,
    this.localeData()._week.doy
);
}

function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(
this,
    input, this.isoWeek(), this.isoWeekday(), 1, 4
);
}

function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear() {
  let weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } 
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
  let dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
    date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

  this.year(date.getUTCFullYear());
  this.month(date.getUTCMonth());
  this.date(date.getUTCDate());
  return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', (input, array) => {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D', match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', (isStrict, locale) => {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', (input, array) => {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

let getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD', match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], (input, array, config) => {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear(input) {
  let dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
  return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m', match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

let getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s', match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

let getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
  return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
  return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
  return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
  return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
  return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
  return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
  return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
  return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S', match1to3, match1);
addRegexToken('SS', match1to3, match2);
addRegexToken('SSS', match1to3, match3);

let token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
  addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
  array[MILLISECOND] = toInt((`0.${  input}`) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
  addParseToken(token, parseMs);
}
// MOMENTS

let getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z', 0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr() {
  return this._isUTC ? 'UTC' : '';
}

function getZoneName() {
  return this._isUTC ? 'Coordinated Universal Time' : '';
}

let proto = Moment.prototype;

proto.add = add;
proto.calendar = calendar$1;
proto.clone = clone;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format;
proto.from = from;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter;
proto.isBefore = isBefore;
proto.isBetween = isBetween;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2;
proto.lang = lang;
proto.locale = locale;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract;
proto.toArray = toArray;
proto.toObject = toObject;
proto.toDate = toDate;
proto.toISOString = toISOString;
proto.inspect = inspect;
proto.toJSON = toJSON;
proto.toString = toString;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;

// Year
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix(input) {
  return createLocal(input * 1000);
}

function createInZone() {
  return createLocal(...arguments).parseZone();
}

function preParsePostFormat(string) {
  return string;
}

let proto$1 = Locale.prototype;

proto$1.calendar = calendar;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set;

// Month
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;

proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1(format, index, field, setter) {
  let locale = getLocale();
  let utc = createUTC().set(setter, index);
  return locale[field](utc, format);
}

function listMonthsImpl(format, index, field) {
  if (isNumber(format)) {
    index = format;
    format = undefined;
  }

  format = format || '';

  if (index != null) {
    return get$1(format, index, field, 'month');
  }

  let i;
  let out = [];
  for (i = 0; i < 12; i++) {
    out[i] = get$1(format, i, field, 'month');
  }
  return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl(localeSorted, format, index, field) {
  if (typeof localeSorted === 'boolean') {
    if (isNumber(format)) {
      index = format;
      format = undefined;
    }

    format = format || '';
  } else {
    format = localeSorted;
    index = format;
    localeSorted = false;

    if (isNumber(format)) {
      index = format;
      format = undefined;
    }

    format = format || '';
  }

  let locale = getLocale(),
    shift = localeSorted ? locale._week.dow : 0;

  if (index != null) {
    return get$1(format, (index + shift) % 7, field, 'day');
  }

  let i;
  let out = [];
  for (i = 0; i < 7; i++) {
    out[i] = get$1(format, (i + shift) % 7, field, 'day');
  }
  return out;
}

function listMonths(format, index) {
  return listMonthsImpl(format, index, 'months');
}

function listMonthsShort(format, index) {
  return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays(localeSorted, format, index) {
  return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort(localeSorted, format, index) {
  return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin(localeSorted, format, index) {
  return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

let mathAbs = Math.abs;

function abs() {
  let data = this._data;

  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);

  data.milliseconds = mathAbs(data.milliseconds);
  data.seconds = mathAbs(data.seconds);
  data.minutes = mathAbs(data.minutes);
  data.hours = mathAbs(data.hours);
  data.months = mathAbs(data.months);
  data.years = mathAbs(data.years);

  return this;
}

function addSubtract$1(duration, input, value, direction) {
  let other = createDuration(input, value);

  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;

  return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1(input, value) {
  return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1(input, value) {
  return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } 
        return Math.ceil(number);
    
}

function bubble() {
  let milliseconds = this._milliseconds;
  let days = this._days;
  let months = this._months;
  let data = this._data;
  let seconds, 
minutes, 
hours, 
years, 
monthsFromDays;

  // if we have a mix of positive and negative values, bubble down first
  // check: https://github.com/moment/moment/issues/2166
  if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
    milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
    days = 0;
    months = 0;
  }

  // The following code bubbles up values, see the tests for
  // examples of what that means.
  data.milliseconds = milliseconds % 1000;

  seconds = absFloor(milliseconds / 1000);
  data.seconds = seconds % 60;

  minutes = absFloor(seconds / 60);
  data.minutes = minutes % 60;

  hours = absFloor(minutes / 60);
  data.hours = hours % 24;

  days += absFloor(hours / 24);

  // convert days to months
  monthsFromDays = absFloor(daysToMonths(days));
  months += monthsFromDays;
  days -= absCeil(monthsToDays(monthsFromDays));

  // 12 months -> 1 year
  years = absFloor(months / 12);
  months %= 12;

  data.days = days;
  data.months = months;
  data.years = years;

  return this;
}

function daysToMonths(days) {
  // 400 years have 146097 days (taking into account leap year rules)
  // 400 years have 12 months === 4800
  return days * 4800 / 146097;
}

function monthsToDays(months) {
  // the reverse of daysToMonths
  return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } 
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    
}

// TODO: Use this.as('ms')?
function valueOf$1() {
  if (!this.isValid()) {
    return NaN;
  }
  return (
    this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
  );
}

function makeAs(alias) {
  return function () {
    return this.as(alias);
  };
}

let asMilliseconds = makeAs('ms');
let asSeconds = makeAs('s');
let asMinutes = makeAs('m');
let asHours = makeAs('h');
let asDays = makeAs('d');
let asWeeks = makeAs('w');
let asMonths = makeAs('M');
let asYears = makeAs('y');

function clone$1() {
  return createDuration(this);
}

function get$2(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[`${units  }s`]() : NaN;
}

function makeGetter(name) {
  return function () {
    return this.isValid() ? this._data[name] : NaN;
  };
}

let milliseconds = makeGetter('milliseconds');
let seconds = makeGetter('seconds');
let minutes = makeGetter('minutes');
let hours = makeGetter('hours');
let days = makeGetter('days');
let months = makeGetter('months');
let years = makeGetter('years');

function weeks() {
  return absFloor(this.days() / 7);
}

let round = Math.round;
let thresholds = {
  ss: 44, // a few seconds to seconds
  s: 45, // seconds to minute
  m: 45, // minutes to hour
  h: 22, // hours to day
  d: 26, // days to month
  M: 11, // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
  return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1(posNegDuration, withoutSuffix, locale) {
  let duration = createDuration(posNegDuration).abs();
  let seconds = round(duration.as('s'));
  let minutes = round(duration.as('m'));
  let hours = round(duration.as('h'));
  let days = round(duration.as('d'));
  let months = round(duration.as('M'));
  let years = round(duration.as('y'));

  let a = seconds <= thresholds.ss && ['s', seconds] ||
            seconds < thresholds.s && ['ss', seconds] ||
            minutes <= 1 && ['m'] ||
            minutes < thresholds.m && ['mm', minutes] ||
            hours <= 1 && ['h'] ||
            hours < thresholds.h && ['hh', hours] ||
            days <= 1 && ['d'] ||
            days < thresholds.d && ['dd', days] ||
            months <= 1 && ['M'] ||
            months < thresholds.M && ['MM', months] ||
            years <= 1 && ['y'] || ['yy', years];

  a[2] = withoutSuffix;
  a[3] = +posNegDuration > 0;
  a[4] = locale;
  return substituteTimeAgo(...a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === undefined) {
    return round;
  }
  if (typeof (roundingFunction) === 'function') {
    round = roundingFunction;
    return true;
  }
  return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === undefined) {
    return false;
  }
  if (limit === undefined) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === 's') {
    thresholds.ss = limit - 1;
  }
  return true;
}

function humanize(withSuffix) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }

  let locale = this.localeData();
  let output = relativeTime$1(this, !withSuffix, locale);

  if (withSuffix) {
    output = locale.pastFuture(+this, output);
  }

  return locale.postformat(output);
}

let abs$1 = Math.abs;

function sign(x) {
  return ((x > 0) - (x < 0)) || +x;
}

function toISOString$1() {
  // for ISO strings we do not use the normal bubbling rules:
  //  * milliseconds bubble up until they become hours
  //  * days do not bubble at all
  //  * months bubble up until they become years
  // This is because there is no context-free conversion between hours and days
  // (think of clock changes)
  // and also not between days and months (28-31 days per month)
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }

  let seconds = abs$1(this._milliseconds) / 1000;
  let days = abs$1(this._days);
  let months = abs$1(this._months);
  let minutes, 
hours, 
years;

  // 3600 seconds -> 60 minutes -> 1 hour
  minutes = absFloor(seconds / 60);
  hours = absFloor(minutes / 60);
  seconds %= 60;
  minutes %= 60;

  // 12 months -> 1 year
  years = absFloor(months / 12);
  months %= 12;


  // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
  let Y = years;
  let M = months;
  let D = days;
  let h = hours;
  let m = minutes;
  let s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
  let total = this.asSeconds();

  if (!total) {
    // this is the same as C#'s (Noda) and python (isodate)...
    // but not other JS (goog.date)
    return 'P0D';
  }

  let totalSign = total < 0 ? '-' : '';
  let ymSign = sign(this._months) !== sign(total) ? '-' : '';
  let daysSign = sign(this._days) !== sign(total) ? '-' : '';
  let hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

  return `${totalSign  }P${ 
        Y ? ymSign + Y + 'Y' : '' 
        }${M ? ymSign + M + 'M' : '' 
        }${D ? daysSign + D + 'D' : '' 
        }${(h || m || s) ? 'T' : '' 
        }${h ? hmsSign + h + 'H' : '' 
        }${m ? hmsSign + m + 'M' : '' 
        }${s ? hmsSign + s + 'S' : ''}`;
}

let proto$2 = Duration.prototype;

proto$2.isValid = isValid$1;
proto$2.abs = abs;
proto$2.add = add$1;
proto$2.subtract = subtract$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1;
proto$2.get = get$2;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale;
proto$2.localeData = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', (input, array, config) => {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', (input, array, config) => {
    config._d = new Date(toInt(input));
});

// Side effect imports

//! moment.js
//! version : 2.19.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

hooks.version = '2.19.1';

setHookCallback(createLocal);

hooks.fn = proto;
hooks.min = min;
hooks.max = max;
hooks.now = now;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;

let asyncGenerator = (function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}());


let classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError('Cannot call a class as a function');
  }
};

let createClass = (function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}());


let defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true,
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

let _extends = Object.assign || function (target) {
  for (let i = 1; i < arguments.length; i++) {
    let source = arguments[i];

    for (let key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};


let inherits = function (subClass, superClass) {
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true,
    },
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};


let objectWithoutProperties = function (obj, keys) {
  let target = {};

  for (let i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

let possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
};

let DateTextField = (function (_Component) {
  inherits(DateTextField, _Component);

  function DateTextField() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, DateTextField);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = DateTextField.__proto__ || Object.getPrototypeOf(DateTextField)).call.apply(_ref, [this].concat(args))), _this), _this.shouldComponentUpdate = function (nextProps) {
      return _this.props.value !== nextProps.value || _this.props.format !== nextProps.format;
    }, _this.getDisplayDate = function () {
      var _this$props = _this.props,
          value = _this$props.value,
          format = _this$props.format;


      return hooks(value).format(format);
    }, _this.handleChange = function (e) {
      var value = e.target.value;

      var momentValue = hooks(value);

      if (momentValue.isValid()) {
        _this.props.onChange(momentValue);
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(DateTextField, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          value = _props.value,
          format = _props.format,
          other = objectWithoutProperties(_props, ['value', 'format']);


      return React__default.createElement(materialUi.TextField, _extends({
        value: this.getDisplayDate(),
        onChange: this.handleChange
      }, other));
    }
  }]);
  return DateTextField;
}(React.Component));

DateTextField.propTypes = {
  value: PropTypes.oneOfType([PropTypes.object, PropTypes.string]).isRequired,
  format: PropTypes.string.isRequired,
  onChange: PropTypes.func,
};

let styles = {
  dialog: {
    '&:first-child': {
      padding: 0,
    },
  },
};

let ModalDialog = function ModalDialog(props) {
  let children = props.children,
    classes = props.classes,
    onAccept = props.onAccept,
    onDismiss = props.onDismiss,
    other = objectWithoutProperties(props, ['children', 'classes', 'onAccept', 'onDismiss']);


  return React__default.createElement(
    materialUi.Dialog,
    other,
    React__default.createElement(
      materialUi.DialogContent,
      { className: classes.dialog },
      children,
    ),
    React__default.createElement(
      materialUi.DialogActions,
      null,
      React__default.createElement(
        materialUi.Button,
        { color: 'primary', onClick: onAccept },
        ' OK ',
      ),
      React__default.createElement(
        materialUi.Button,
        { color: 'primary', onClick: onDismiss },
        ' Cancel ',
      ),
    ),
  );
};

ModalDialog.propTypes = {
  children: PropTypes.node.isRequired,
  onAccept: PropTypes.func.isRequired,
  onDismiss: PropTypes.func.isRequired,
  classes: PropTypes.object.isRequired,
};

let ModalDialog$1 = materialUi.withStyles(styles, { name: 'MuiPickersModal' })(ModalDialog);

let pickerStyles = (function (theme) {
  return {
    container: {
      width: 300,
      height: 420,
    },
    toolbar: {
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'flex-start',
      justifyContent: 'center',
      backgroundColor: theme.palette.primary[500],
      height: 100,
    },
  };
});

'use strict';

let validTypes = { object: true, symbol: true };

let isImplemented = function () {
  if (typeof Symbol !== 'function') return false;
  try { } catch (e) { return false; }

  // Return 'true' also for polyfills
  if (!validTypes[typeof Symbol.iterator]) return false;
  if (!validTypes[typeof Symbol.toPrimitive]) return false;
  if (!validTypes[typeof Symbol.toStringTag]) return false;

  return true;
};

function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}

'use strict';

let isImplemented$2 = function () {
  let assign = Object.assign, 
obj;
  if (typeof assign !== 'function') return false;
  obj = { foo: 'raz' };
  assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
  return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
};

'use strict';

let isImplemented$4 = function () {
  try {
    return true;
  } catch (e) {
    return false;
  }
};

'use strict';

// eslint-disable-next-line no-empty-function
let noop = function () {};

'use strict';

let _undefined = noop(); // Support ES3 engines

let isValue = function (val) {
  return (val !== _undefined) && (val !== null);
};

'use strict';


let keys$3 = Object.keys;

let shim$2 = function (object) {
  return keys$3(isValue(object) ? Object(object) : object);
};

'use strict';

let keys$1 = isImplemented$4()
  ? Object.keys
  : shim$2;

'use strict';


let validValue = function (value) {
  if (!isValue(value)) throw new TypeError('Cannot use null or undefined');
  return value;
};

'use strict';

let max$1 = Math.max;

let shim = function (dest, src /* , srcn*/) {
  let error, 
i, 
length = max$1(arguments.length, 2), 
assign;
  dest = Object(validValue(dest));
  assign = function (key) {
    try {
      dest[key] = src[key];
    } catch (e) {
      if (!error) error = e;
    }
  };
  for (i = 1; i < length; ++i) {
    src = arguments[i];
    keys$1(src).forEach(assign);
  }
  if (error !== undefined) throw error;
  return dest;
};

'use strict';

let assign = isImplemented$2()
  ? Object.assign
  : shim;

'use strict';


let forEach = Array.prototype.forEach;
let create$1 = Object.create;

let process = function (src, obj) {
  let key;
  for (key in src) obj[key] = src[key];
};

// eslint-disable-next-line no-unused-vars
let normalizeOptions = function (opts1 /* , options*/) {
  let result = create$1(null);
  forEach.call(arguments, (options) => {
		if (!isValue(options)) return;
		process(Object(options), result);
	});
  return result;
};

// Deprecated

'use strict';

let isCallable = function (obj) {
  return typeof obj === 'function';
};

'use strict';

let str = 'razdwatrzy';

let isImplemented$6 = function () {
  if (typeof str.contains !== 'function') return false;
  return (str.contains('dwa') === true) && (str.contains('foo') === false);
};

'use strict';

let indexOf$1 = String.prototype.indexOf;

let shim$4 = function (searchString/* , position*/) {
  return indexOf$1.call(this, searchString, arguments[1]) > -1;
};

'use strict';

let contains = isImplemented$6()
  ? String.prototype.contains
  : shim$4;

let d_1 = createCommonjsModule((module) => {
'use strict';

var d;

d = module.exports = function (dscr, value/*, options*/) {
	var c, e, w, options, desc;
	if ((arguments.length < 2) || (typeof dscr !== 'string')) {
		options = value;
		value = dscr;
		dscr = null;
	} else {
		options = arguments[2];
	}
	if (dscr == null) {
		c = w = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
		w = contains.call(dscr, 'w');
	}

	desc = { value: value, configurable: c, enumerable: e, writable: w };
	return !options ? desc : assign(normalizeOptions(options), desc);
};

d.gs = function (dscr, get, set/*, options*/) {
	var c, e, options, desc;
	if (typeof dscr !== 'string') {
		options = set;
		set = get;
		get = dscr;
		dscr = null;
	} else {
		options = arguments[3];
	}
	if (get == null) {
		get = undefined;
	} else if (!isCallable(get)) {
		options = get;
		get = set = undefined;
	} else if (set == null) {
		set = undefined;
	} else if (!isCallable(set)) {
		options = set;
		set = undefined;
	}
	if (dscr == null) {
		c = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
	}

	desc = { get: get, set: set, configurable: c, enumerable: e };
	return !options ? desc : assign(normalizeOptions(options), desc);
};
});

'use strict';

let isSymbol = function (x) {
  if (!x) return false;
  if (typeof x === 'symbol') return true;
  if (!x.constructor) return false;
  if (x.constructor.name !== 'Symbol') return false;
  return (x[x.constructor.toStringTag] === 'Symbol');
};

'use strict';


let validateSymbol = function (value) {
  if (!isSymbol(value)) throw new TypeError(`${value  } is not a symbol`);
  return value;
};

// ES2015 Symbol polyfill for environments that do not (or partially) support it

'use strict';

let create = Object.create;
let defineProperties = Object.defineProperties;
let defineProperty$1 = Object.defineProperty;
let objPrototype = Object.prototype;
let NativeSymbol;
let SymbolPolyfill;
let HiddenSymbol;
let globalSymbols = create(null);
let isNativeSafe;

if (typeof Symbol === 'function') {
  NativeSymbol = Symbol;
  try {
    isNativeSafe = true;
  } catch (ignore) {}
}

let generateName = (function () {
  let created = create(null);
  return function (desc) {
    let postfix = 0, 
name, 
ie11BugWorkaround;
    while (created[desc + (postfix || '')]) ++postfix;
    desc += (postfix || '');
    created[desc] = true;
    name = `@@${  desc}`;
    defineProperty$1(objPrototype, name, d_1.gs(null, function (value) {
      // For IE11 issue see:
      // https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
      //    ie11-broken-getters-on-dom-objects
      // https://github.com/medikoo/es6-symbol/issues/12
      if (ie11BugWorkaround) return;
      ie11BugWorkaround = true;
      defineProperty$1(this, name, d_1(value));
      ie11BugWorkaround = false;
    }));
    return name;
  };
}());

// Internal constructor (not one exposed) for creating Symbol instances.
// This one is used to ensure that `someSymbol instanceof Symbol` always return false
HiddenSymbol = function Symbol(description) {
  if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
  return SymbolPolyfill(description);
};

// Exposed `Symbol` constructor
// (returns instances of HiddenSymbol)
let polyfill = SymbolPolyfill = function Symbol(description) {
  let symbol;
  if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
  if (isNativeSafe) return NativeSymbol(description);
  symbol = create(HiddenSymbol.prototype);
  description = (description === undefined ? '' : String(description));
  return defineProperties(symbol, {
    __description__: d_1('', description),
    __name__: d_1('', generateName(description)),
  });
};
defineProperties(SymbolPolyfill, {
  for: d_1((key) => {
		if (globalSymbols[key]) return globalSymbols[key];
		return (globalSymbols[key] = SymbolPolyfill(String(key)));
	}),
  keyFor: d_1((s) => {
		var key;
		validateSymbol(s);
		for (key in globalSymbols) if (globalSymbols[key] === s) return key;
	}),

  // To ensure proper interoperability with other native functions (e.g. Array.from)
  // fallback to eventual native implementation of given symbol
  hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
  isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
  SymbolPolyfill('isConcatSpreadable')),
  iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
  match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
  replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
  search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
  species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
  split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
  toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
  toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
  unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables')),
});

// Internal tweaks for real symbol producer
defineProperties(HiddenSymbol.prototype, {
  constructor: d_1(SymbolPolyfill),
  toString: d_1('', function () { return this.__name__; }),
});

// Proper implementation of methods exposed on Symbol.prototype
// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
defineProperties(SymbolPolyfill.prototype, {
  toString: d_1(function () { return `Symbol (${  validateSymbol(this).__description__  })`; }),
  valueOf: d_1(function () { return validateSymbol(this); }),
});
defineProperty$1(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
  let symbol = validateSymbol(this);
  if (typeof symbol === 'symbol') return symbol;
  return symbol.toString();
}));
defineProperty$1(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
defineProperty$1(
HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
  d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])
);

// Note: It's important to define `toPrimitive` as last one, as some implementations
// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
// And that may invoke error in definition flow:
// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
defineProperty$1(
HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
  d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])
);

'use strict';

let es6Symbol = isImplemented() ? Symbol : polyfill;

//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

const INTERVALS = {
  year: true,
  quarter: true,
  month: true,
  week: true,
  day: true,
  hour: true,
  minute: true,
  second: true,
};


//-----------------------------------------------------------------------------
// Date Ranges
//-----------------------------------------------------------------------------

class DateRange {
  constructor(start, end) {
    let s = start;
    let e = end;

    if (arguments.length === 1 || end === undefined) {
      if (typeof start === 'object' && start.length === 2) {
        [s, e] = start;
      } else if (typeof start === 'string') {
        [s, e] = start.split('/');
      }
    }

    this.start = (s === null) ? hooks(-8640000000000000) : hooks(s);
    this.end = (e === null) ? hooks(8640000000000000) : hooks(e);
  }

  adjacent(other) {
    const sameStartEnd = this.start.isSame(other.end);
    const sameEndStart = this.end.isSame(other.start);

    return (sameStartEnd && (other.start.valueOf() <= this.start.valueOf())) || (sameEndStart && (other.end.valueOf() >= this.end.valueOf()));
  }

  add(other) {
    if (this.overlaps(other)) {
      return new this.constructor(hooks.min(this.start, other.start), hooks.max(this.end, other.end));
    }

    return null;
  }

  by(interval, options = { exclusive: false, step: 1 }) {
    const range = this;

    return {
      [es6Symbol.iterator]() {
        const exclusive = options.exclusive || false;
        const step = options.step || 1;
        const diff = Math.abs(range.start.diff(range.end, interval)) / step;
        let iteration = 0;

        return {
          next() {
            const current = range.start.clone().add((iteration * step), interval);
            const done = exclusive
              ? !(iteration < diff)
              : !(iteration <= diff);

            iteration++;

            return {
              done,
              value: (done ? undefined : current),
            };
          },
        };
      },
    };
  }

  byRange(interval, options = { exclusive: false, step: 1 }) {
    const range = this;
    const step = options.step || 1;
    const diff = this.valueOf() / interval.valueOf() / step;
    const exclusive = options.exclusive || false;
    const unit = Math.floor(diff);
    let iteration = 0;

    return {
      [es6Symbol.iterator]() {
        if (unit === Infinity) {
          return { done: true };
        }

        return {
          next() {
            const current = hooks(range.start.valueOf() + (interval.valueOf() * iteration * step));
            const done = ((unit === diff) && exclusive)
              ? !(iteration < unit)
              : !(iteration <= unit);

            iteration++;

            return {
              done,
              value: (done ? undefined : current),
            };
          },
        };
      },
    };
  }

  center() {
    const center = this.start.valueOf() + this.diff() / 2;

    return hooks(center);
  }

  clone() {
    return new this.constructor(this.start, this.end);
  }

  contains(other, options = { exclusive: false }) {
    const start = this.start.valueOf();
    const end = this.end.valueOf();
    let oStart = other.valueOf();
    let oEnd = other.valueOf();

    if (other instanceof DateRange) {
      oStart = other.start.valueOf();
      oEnd = other.end.valueOf();
    }

    const startInRange = (start < oStart) || ((start <= oStart) && !options.exclusive);
    const endInRange = (end > oEnd) || ((end >= oEnd) && !options.exclusive);

    return (startInRange && endInRange);
  }

  diff(unit, rounded) {
    return this.end.diff(this.start, unit, rounded);
  }

  duration(unit, rounded) {
    return this.diff(unit, rounded);
  }

  intersect(other) {
    const start = this.start.valueOf();
    const end = this.end.valueOf();
    const oStart = other.start.valueOf();
    const oEnd = other.end.valueOf();

    if ((start <= oStart) && (oStart < end) && (end < oEnd)) {
      return new this.constructor(oStart, end);
    } else if ((oStart < start) && (start < oEnd) && (oEnd <= end)) {
      return new this.constructor(start, oEnd);
    } else if ((oStart < start) && (start <= end) && (end < oEnd)) {
      return this;
    } else if ((start <= oStart) && (oStart <= oEnd) && (oEnd <= end)) {
      return other;
    }

    return null;
  }

  isEqual(other) {
    return this.start.isSame(other.start) && this.end.isSame(other.end);
  }

  isSame(other) {
    return this.isEqual(other);
  }

  overlaps(other, options = { adjacent: false }) {
    const intersect = (this.intersect(other) !== null);

    if (options.adjacent && !intersect) {
      return this.adjacent(other);
    }

    return intersect;
  }

  reverseBy(interval, options = { exclusive: false, step: 1 }) {
    const range = this;

    return {
      [es6Symbol.iterator]() {
        const exclusive = options.exclusive || false;
        const step = options.step || 1;
        const diff = Math.abs(range.start.diff(range.end, interval)) / step;
        let iteration = 0;

        return {
          next() {
            const current = range.end.clone().subtract((iteration * step), interval);
            const done = exclusive
              ? !(iteration < diff)
              : !(iteration <= diff);

            iteration++;

            return {
              done,
              value: (done ? undefined : current),
            };
          },
        };
      },
    };
  }

  reverseByRange(interval, options = { exclusive: false, step: 1 }) {
    const range = this;
    const step = options.step || 1;
    const diff = this.valueOf() / interval.valueOf() / step;
    const exclusive = options.exclusive || false;
    const unit = Math.floor(diff);
    let iteration = 0;

    return {
      [es6Symbol.iterator]() {
        if (unit === Infinity) {
          return { done: true };
        }

        return {
          next() {
            const current = hooks(range.end.valueOf() - (interval.valueOf() * iteration * step));
            const done = ((unit === diff) && exclusive)
              ? !(iteration < unit)
              : !(iteration <= unit);

            iteration++;

            return {
              done,
              value: (done ? undefined : current),
            };
          },
        };
      },
    };
  }

  subtract(other) {
    const start = this.start.valueOf();
    const end = this.end.valueOf();
    const oStart = other.start.valueOf();
    const oEnd = other.end.valueOf();

    if (this.intersect(other) === null) {
      return [this];
    } else if ((oStart <= start) && (start < end) && (end <= oEnd)) {
      return [];
    } else if ((oStart <= start) && (start < oEnd) && (oEnd < end)) {
      return [new this.constructor(oEnd, end)];
    } else if ((start < oStart) && (oStart < end) && (end <= oEnd)) {
      return [new this.constructor(start, oStart)];
    } else if ((start < oStart) && (oStart < oEnd) && (oEnd < end)) {
      return [new this.constructor(start, oStart), new this.constructor(oEnd, end)];
    } else if ((start < oStart) && (oStart < end) && (oEnd < end)) {
      return [new this.constructor(start, oStart), new this.constructor(oStart, end)];
    }

    return [];
  }

  toDate() {
    return [this.start.toDate(), this.end.toDate()];
  }

  toString() {
    return `${this.start.format()  }/${  this.end.format()}`;
  }

  valueOf() {
    return this.end.valueOf() - this.start.valueOf();
  }
}


//-----------------------------------------------------------------------------
// Moment Extensions
//-----------------------------------------------------------------------------

function extendMoment(moment) {
  /**
   * Build a date range.
   */
  moment.range = function range(start, end) {
    const m = this;

    if (INTERVALS.hasOwnProperty(start)) {
      return new DateRange(moment(m).startOf(start), moment(m).endOf(start));
    }

    return new DateRange(start, end);
  };

  /**
   * Alias of static constructor.
   */
  moment.fn.range = moment.range;

  /**
   * Expose constructor
   */
  moment.range.constructor = DateRange;

  /**
   * Check if the current moment is within a given date range.
   */
  moment.fn.within = function (range) {
    return range.contains(this.toDate());
  };

  return moment;
}

let CalendarHeader = function CalendarHeader(props) {
  let classes = props.classes,
    currentMonth = props.currentMonth,
    onMonthChange = props.onMonthChange;


  let selectNextMonth = function selectNextMonth() {
    return onMonthChange(currentMonth.clone().add(1, 'months'));
  };
  let selectPreviousMonth = function selectPreviousMonth() {
    return onMonthChange(currentMonth.clone().subtract(1, 'months'));
  };

  return React__default.createElement(
    'div',
    null,
    React__default.createElement(
      'div',
      { className: classes.switchHeader },
      React__default.createElement(
        materialUi.IconButton,
        { onClick: selectPreviousMonth },
        'keyboard_arrow_left',
      ),
      React__default.createElement(
        'div',
        { className: classes.monthName },
        currentMonth.format('MMMM YYYY'),
      ),
      React__default.createElement(
        materialUi.IconButton,
        { onClick: selectNextMonth },
        'keyboard_arrow_right',
      ),
    ),
    React__default.createElement(
      'div',
      { className: classes.daysHeader },
      hooks.weekdaysMin().map((day) => {
        return React__default.createElement(
          'div',
          { key: day, className: classes.dayLabel },
          ' ',
          day,
          ' '
        );
      }),
    ),
  );
};

CalendarHeader.propTypes = {
  currentMonth: PropTypes.object.isRequired,
  onMonthChange: PropTypes.func.isRequired,
  classes: PropTypes.object.isRequired,
};

let styles$3 = function styles(theme) {
  return {
    switchHeader: {
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
      margin: '10px 0 20px',
    },
    daysHeader: {
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
    },
    dayLabel: {
      width: 36,
      margin: '0 2px',
      fontSize: 13,
      textAlign: 'center',
      color: theme.palette.text.hint,
    },
  };
};

let CalendarHeader$1 = materialUi.withStyles(styles$3)(CalendarHeader, { name: 'MuiPickersCalendarHeader' });

let moment$1 = extendMoment(hooks);

let Calendar = (function (_PureComponent) {
  inherits(Calendar, _PureComponent);

  function Calendar() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Calendar);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Calendar.__proto__ || Object.getPrototypeOf(Calendar)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      currentMonth: _this.props.date.clone().startOf('month')
    }, _this.onDateSelect = function (day) {
      _this.props.onChange(day);
    }, _this.handleChangeMonth = function (newMonth) {
      _this.setState({ currentMonth: newMonth });
    }, _this.renderWeeks = function () {
      var currentMonth = _this.state.currentMonth;

      var start = currentMonth.clone().startOf('week');
      var end = currentMonth.clone().endOf('month').endOf('week');

      return Array.from(moment$1.range(start, end).by('week')).map(function (week) {
        return React__default.createElement(
          'div',
          { key: 'week-' + week.toString(), className: _this.props.classes.week },
          _this.renderDays(week)
        );
      });
    }, _this.renderDays = function (week) {
      var _this$props = _this.props,
          disableFuture = _this$props.disableFuture,
          classes = _this$props.classes,
          date = _this$props.date;

      var end = week.clone().endOf('week');
      var currentMonthNumber = _this.state.currentMonth.get('month');

      return Array.from(moment$1.range(week, end).by('day')).map(function (day) {
        var _classnames;

        var dayClass = classnames(classes.day, (_classnames = {}, defineProperty(_classnames, classes.hidden, day.get('month') !== currentMonthNumber), defineProperty(_classnames, classes.selected, day.toString() === date.toString()), defineProperty(_classnames, classes.disabled, disableFuture && day.isAfter(moment$1())), _classnames));

        return React__default.createElement(
          materialUi.IconButton,
          {
            key: day.toString(),
            className: dayClass,
            onClick: function onClick() {
              return _this.onDateSelect(day);
            }
          },
          React__default.createElement(
            'span',
            null,
            ' ',
            day.format('DD'),
            ' '
          )
        );
      });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Calendar, [{
    key: 'render',
    value: function render() {
      var currentMonth = this.state.currentMonth;
      var classes = this.props.classes;


      return React__default.createElement(
        'div',
        { className: classes.container },
        React__default.createElement(CalendarHeader$1, {
          currentMonth: currentMonth,
          onMonthChange: this.handleChangeMonth
        }),
        React__default.createElement(
          'div',
          { className: classes.calendar },
          this.renderWeeks()
        )
      );
    }
  }]);
  return Calendar;
}(React.PureComponent));

Calendar.propTypes = {
  date: PropTypes.object.isRequired,
  classes: PropTypes.object.isRequired,
  onChange: PropTypes.func.isRequired,
  disableFuture: PropTypes.bool.isRequired,
};


let styles$2 = function styles(theme) {
  return {
    calendar: {
      marginTop: 10,
    },
    hidden: {
      opacity: 0,
      pointerEvents: 'none',
    },
    day: {
      width: 36,
      height: 36,
      fontSize: 14,
      margin: '0 2px',
      color: theme.palette.text.primary,
    },
    selected: {
      color: theme.palette.primary[700],
      backgroundColor: theme.palette.primary[200],
    },
    disabled: {
      pointerEvents: 'none',
      color: theme.palette.text.hint,
    },
    week: {
      display: 'flex',
      justifyContent: 'center',
    },
  };
};

let Calendar$1 = materialUi.withStyles(styles$2, { name: 'MuiPickersCalendar' })(Calendar);

let moment$2 = extendMoment(hooks);

let YearSelection = (function (_PureComponent) {
  inherits(YearSelection, _PureComponent);

  function YearSelection() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, YearSelection);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = YearSelection.__proto__ || Object.getPrototypeOf(YearSelection)).call.apply(_ref, [this].concat(args))), _this), _this.componentDidMount = function () {
      var animateYearScrolling = _this.props.animateYearScrolling;

      var currentYearElement = document.getElementsByClassName(_this.props.classes.selectedYear)[0];

      if (currentYearElement) {
        currentYearElement.scrollIntoView({
          behavior: animateYearScrolling ? 'smooth' : 'auto'
        });
      }
    }, _this.onYearSelect = function (year) {
      var _this$props = _this.props,
          date = _this$props.date,
          onChange = _this$props.onChange;


      var newDate = date.clone().set('year', year);
      onChange(newDate);
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(YearSelection, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          minDate = _props.minDate,
          maxDate = _props.maxDate,
          date = _props.date,
          classes = _props.classes,
          disableFuture = _props.disableFuture;

      var currentYear = date.get('year');

      return React__default.createElement(
        'div',
        { className: classes.container },
        Array.from(moment$2.range(minDate, maxDate).by('year')).map(function (year) {
          var _classnames;

          var yearNumber = year.get('year');
          var className = classnames(classes.yearItem, (_classnames = {}, defineProperty(_classnames, classes.selectedYear, yearNumber === currentYear), defineProperty(_classnames, classes.disabled, disableFuture && year.isAfter(moment$2())), _classnames));

          return React__default.createElement(
            'div',
            {
              role: 'button',
              key: year.format('YYYY'),
              className: className,
              tabIndex: yearNumber,
              onClick: function onClick() {
                return _this2.onYearSelect(yearNumber);
              },
              onKeyPress: function onKeyPress() {
                return _this2.onYearSelect(yearNumber);
              }
            },
            yearNumber
          );
        })
      );
    }
  }]);
  return YearSelection;
}(React.PureComponent));

YearSelection.propTypes = {
  date: PropTypes.shape({}).isRequired,
  minDate: PropTypes.shape({}).isRequired,
  maxDate: PropTypes.shape({}).isRequired,
  classes: PropTypes.object.isRequired,
  onChange: PropTypes.func.isRequired,
  disableFuture: PropTypes.bool.isRequired,
  animateYearScrolling: PropTypes.bool.isRequired,
};


let styles$4 = function styles(theme) {
  return {
    container: {
      maxHeight: 320,
      overflowY: 'auto',
      justifyContent: 'center',
    },
    yearItem: {
      height: 36,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      cursor: 'pointer',
      outline: 'none',
    },
    selectedYear: {
      fontSize: 26,
      margin: '10px 0',
      color: theme.palette.primary[500],
    },
    disabled: {
      pointerEvents: 'none',
      color: theme.palette.text.hint,
    },
  };
};

let YearSelection$1 = materialUi.withStyles(styles$4, { name: 'MuiPickersYearSelection' })(YearSelection);

let ToolbarButton = function ToolbarButton(props) {
  let classes = props.classes,
    selected = props.selected,
    label = props.label,
    className = props.className,
    other = objectWithoutProperties(props, ['classes', 'selected', 'label', 'className']);


  return React__default.createElement(
    materialUi.Typography,
    _extends({
      className: classnames(classes.toolbarBtn, className, defineProperty({}, classes.toolbarBtnSelected, selected)),
    }, other),
    label,
  );
};

ToolbarButton.propTypes = {
  selected: PropTypes.bool.isRequired,
  label: PropTypes.string.isRequired,
  classes: PropTypes.object.isRequired,
  className: PropTypes.string,
};

let styles$5 = function styles(theme) {
  return {
    toolbarBtn: {
      cursor: 'pointer',
      color: theme.palette.common.lightWhite,
    },
    toolbarBtnSelected: {
      color: theme.palette.common.white,
    },
  };
};

let ToolbarButton$1 = materialUi.withStyles(styles$5, { name: 'MuiPickersToolbarButton' })(ToolbarButton);

let DatePicker = (function (_PureComponent) {
  inherits(DatePicker, _PureComponent);

  function DatePicker() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, DatePicker);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = DatePicker.__proto__ || Object.getPrototypeOf(DatePicker)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      showYearSelection: _this.props.openToYearSelection
    }, _this.openYearSelection = function () {
      _this.setState({ showYearSelection: true });
    }, _this.openCalendar = function () {
      _this.setState({ showYearSelection: false });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(DatePicker, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          classes = _props.classes,
          disableFuture = _props.disableFuture,
          onChange = _props.onChange,
          animateYearScrolling = _props.animateYearScrolling;
      var showYearSelection = this.state.showYearSelection;


      return React__default.createElement(
        'div',
        { className: classes.container },
        React__default.createElement(
          materialUi.Toolbar,
          { className: classes.toolbar },
          React__default.createElement(ToolbarButton$1, {
            type: 'subheading',
            onClick: this.openYearSelection,
            selected: showYearSelection,
            label: this.date.format('YYYY')
          }),
          React__default.createElement(ToolbarButton$1, {
            type: 'display1',
            onClick: this.openCalendar,
            selected: !showYearSelection,
            label: this.date.format('ddd, MMM DD')
          })
        ),
        showYearSelection ? React__default.createElement(YearSelection$1, {
          date: this.date,
          onChange: onChange,
          minDate: this.minDate,
          maxDate: this.maxDate,
          disableFuture: disableFuture,
          animateYearScrolling: animateYearScrolling
        }) : React__default.createElement(Calendar$1, {
          date: this.date,
          onChange: onChange,
          disableFuture: disableFuture
        })
      );
    }
  }, {
    key: 'date',
    get: function get() {
      return this.props.date.startOf('day');
    }
  }, {
    key: 'minDate',
    get: function get() {
      return hooks(this.props.minDate);
    }
  }, {
    key: 'maxDate',
    get: function get() {
      return hooks(this.props.maxDate);
    }
  }]);
  return DatePicker;
}(React.PureComponent));

DatePicker.propTypes = {
  date: PropTypes.object,
  minDate: PropTypes.oneOfType([PropTypes.object, PropTypes.string, PropTypes.number]),
  maxDate: PropTypes.oneOfType([PropTypes.object, PropTypes.string, PropTypes.number]),
  classes: PropTypes.shape({}).isRequired,
  onChange: PropTypes.func.isRequired,
  disableFuture: PropTypes.bool,
  animateYearScrolling: PropTypes.bool,
  openToYearSelection: PropTypes.bool,
};
DatePicker.defaultProps = {
  minDate: '1900-01-01',
  maxDate: '2100-01-01',
  disableFuture: false,
  animateYearScrolling: true,
  openToYearSelection: false,
};


let styles$1 = function styles(theme) {
  return _extends({}, pickerStyles(theme));
};

let DatePicker$1 = materialUi.withStyles(styles$1, { name: 'MuiPickersDatePicker' })(DatePicker);

let DatePickerModal = (function (_PureComponent) {
  inherits(DatePickerModal, _PureComponent);

  function DatePickerModal() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, DatePickerModal);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = DatePickerModal.__proto__ || Object.getPrototypeOf(DatePickerModal)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      open: false,
      date: hooks(_this.props.value)
    }, _this.togglePicker = function () {
      _this.setState({ open: !_this.state.open });
    }, _this.handleChange = function (date) {
      _this.setState({ date: date }, function () {
        if (_this.props.autoOk) {
          _this.handleAccept();
        }
      });
    }, _this.handleAccept = function () {
      _this.props.onChange(_this.state.date);
      _this.togglePicker(); // close
    }, _this.handleDismiss = function () {
      _this.setState({
        date: hooks(_this.props.value)
      });

      _this.togglePicker();
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(DatePickerModal, [{
    key: 'render',
    value: function render() {
      var date = this.state.date;
      var _props = this.props,
          value = _props.value,
          format = _props.format,
          autoOk = _props.autoOk,
          onChange = _props.onChange,
          disableFuture = _props.disableFuture,
          animateYearScrolling = _props.animateYearScrolling,
          openToYearSelection = _props.openToYearSelection,
          other = objectWithoutProperties(_props, ['value', 'format', 'autoOk', 'onChange', 'disableFuture', 'animateYearScrolling', 'openToYearSelection']);


      return React__default.createElement(
        'span',
        null,
        React__default.createElement(DateTextField, _extends({
          value: value,
          format: format,
          onClick: this.togglePicker
        }, other)),
        React__default.createElement(
          ModalDialog$1,
          {
            open: this.state.open,
            onAccept: this.handleAccept,
            onDismiss: this.handleDismiss
          },
          React__default.createElement(DatePicker$1, {
            date: date,
            onChange: this.handleChange,
            disableFuture: disableFuture,
            animateYearScrolling: animateYearScrolling,
            openToYearSelection: openToYearSelection
          })
        )
      );
    }
  }]);
  return DatePickerModal;
}(React.PureComponent));

DatePickerModal.propTypes = {
  value: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),
  format: PropTypes.string,
  onChange: PropTypes.func.isRequired,
  autoOk: PropTypes.bool,
  disableFuture: PropTypes.bool,
  animateYearScrolling: PropTypes.bool,
  openToYearSelection: PropTypes.bool,
};
DatePickerModal.defaultProps = {
  value: null,
  format: 'MMMM Do',
  autoOk: false,
  disableFuture: false,
  animateYearScrolling: false,
  openToYearSelection: false,
};

let ClockPointer = (function (_Component) {
  inherits(ClockPointer, _Component);

  function ClockPointer() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, ClockPointer);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ClockPointer.__proto__ || Object.getPrototypeOf(ClockPointer)).call.apply(_ref, [this].concat(args))), _this), _this.getAngleStyle = function () {
      var _this$props = _this.props,
          value = _this$props.value,
          max = _this$props.max;

      var angle = 360 / max * value;

      return {
        transform: 'rotateZ(' + angle + 'deg)'
      };
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(ClockPointer, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          classes = _props.classes,
          hasSelected = _props.hasSelected;


      return React__default.createElement(
        'div',
        {
          className: classes.pointer,
          style: this.getAngleStyle()
        },
        React__default.createElement('div', { className: classnames(classes.thumb, defineProperty({}, classes.noPoint, hasSelected)) })
      );
    }
  }]);
  return ClockPointer;
}(React.Component));

ClockPointer.propTypes = {
  classes: PropTypes.object.isRequired,
  value: PropTypes.number.isRequired,
  hasSelected: PropTypes.bool.isRequired,
  max: PropTypes.number.isRequired,
};


let styles$8 = function styles(theme) {
  return {
    pointer: {
      width: 2,
      backgroundColor: theme.palette.primary[500],
      height: '40%',
      position: 'absolute',
      left: 'calc(50% - 1px)',
      bottom: '50%',
      transformOrigin: 'center bottom 0px',
    },
    thumb: {
      width: 4,
      height: 4,
      backgroundColor: theme.palette.common.white,
      borderRadius: '100%',
      position: 'absolute',
      top: -21,
      left: -15,
      border: `14px solid ${  theme.palette.primary[500]}`,
      boxSizing: 'content-box',
    },
    noPoint: {
      backgroundColor: theme.palette.primary[500],
    },
  };
};

let ClockPointer$1 = materialUi.withStyles(styles$8, { name: 'MuiPickersClockPointer' })(ClockPointer);

let HOURS = 'hours';

let MINUTES = 'minutes';

let clockType = Object.freeze({
  HOURS,
  MINUTES,
});

let center = {
  x: 260 / 2,
  y: 260 / 2,
};

let basePoint = {
  x: center.x,
  y: 0,
};

let cx = basePoint.x - center.x;
let cy = basePoint.y - center.y;

let rad2deg = function rad2deg(rad) {
  return rad * 57.29577951308232;
};

let getAngleValue = function getAngleValue(step, offsetX, offsetY) {
  let x = offsetX - center.x;
  let y = offsetY - center.y;

  let atan = Math.atan2(cx, cy) - Math.atan2(x, y);

  let deg = rad2deg(atan);
  deg = Math.round(deg / step) * step;
  deg %= 360;

  let value = Math.floor(deg / step) || 0;

  return value;
};

let getHours = function getHours(offsetX, offsetY) {
  let value = getAngleValue(30, offsetX, offsetY) || 12;

  return value % 12;
};

let getMinutes = function getMinutes(offsetX, offsetY) {
  let step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 6;

  let value = getAngleValue(step, offsetX, offsetY);

  return value;
};

let Clock = (function (_Component) {
  inherits(Clock, _Component);

  function Clock() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Clock);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Clock.__proto__ || Object.getPrototypeOf(Clock)).call.apply(_ref, [this].concat(args))), _this), _this.handleUp = function (event) {
      event.preventDefault();
      _this.setTime(event.nativeEvent, true);
    }, _this.handleMove = function (e) {
      e.preventDefault();
      if (e.buttons !== 1) {
        return;
      }

      _this.setTime(e.nativeEvent, false);
    }, _this.hasSelected = function () {
      var _this$props = _this.props,
          type = _this$props.type,
          value = _this$props.value;


      if (type === HOURS) {
        return true;
      }

      return value % 5 === 0;
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Clock, [{
    key: 'setTime',
    value: function setTime(e, finish) {
      if (typeof e.offsetX === 'undefined') {
        console.warn('Touch events not supporting');
      }

      var value = this.props.type === MINUTES ? getMinutes(e.offsetX, e.offsetY) : getHours(e.offsetX, e.offsetY);

      this.props.onChange(value, finish);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          classes = _props.classes,
          value = _props.value,
          children = _props.children,
          type = _props.type;


      return React__default.createElement(
        'div',
        { className: classes.container },
        React__default.createElement(
          'div',
          {
            className: classes.clock
          },
          React__default.createElement('div', {
            className: classes.squareMask,
            onTouchMove: this.handleTouchMove,
            onTouchEnd: this.handleTouchEnd,
            onMouseUp: this.handleUp,
            onMouseMove: this.handleMove
          }),
          React__default.createElement(ClockPointer$1, {
            max: type === HOURS ? 12 : 60,
            hasSelected: this.hasSelected(),
            value: value
          }),
          children
        )
      );
    }
  }]);
  return Clock;
}(React.Component));

Clock.propTypes = {
  type: PropTypes.oneOf(Object.values(clockType)).isRequired,
  classes: PropTypes.object.isRequired,
  value: PropTypes.number.isRequired,
  onChange: PropTypes.func.isRequired,
  children: PropTypes.arrayOf(PropTypes.node).isRequired,
};


let styles$7 = function styles(theme) {
  return {
    container: {
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'flex-end',
      marginTop: 40,
    },
    clock: {
      backgroundColor: 'rgba(0,0,0,.07)',
      borderRadius: '50%',
      height: 260,
      width: 260,
      position: 'relative',
      pointerEvents: 'none',
    },
    squareMask: {
      width: '100%',
      height: '100%',
      position: 'absolute',
      pointerEvents: 'auto',
    },
  };
};

let Clock$1 = materialUi.withStyles(styles$7, { name: 'MuiPickersClock' })(Clock);

let positions = [[0, 5], [55, 19.6], [94.4, 59.5], [109, 114], [94.4, 168.5], [54.5, 208.4], [0, 223], [-54.5, 208.4], [-94.4, 168.5], [-109, 114], [-94.4, 59.5], [-54.5, 19.6]];

let ClockNumber = (function (_Component) {
  inherits(ClockNumber, _Component);

  function ClockNumber() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, ClockNumber);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ClockNumber.__proto__ || Object.getPrototypeOf(ClockNumber)).call.apply(_ref, [this].concat(args))), _this), _this.getTransformStyle = function (index) {
      var position = positions[index];

      return {
        transform: 'translate(' + position[0] + 'px, ' + position[1] + 'px'
      };
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(ClockNumber, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          selected = _props.selected,
          label = _props.label,
          index = _props.index,
          classes = _props.classes;


      var className = classnames(classes.clockNumber, defineProperty({}, classes.selected, selected));

      return React__default.createElement(
        'div',
        {
          className: className,
          style: this.getTransformStyle(index)
        },
        label
      );
    }
  }]);
  return ClockNumber;
}(React.Component));

ClockNumber.propTypes = {
  index: PropTypes.number.isRequired,
  label: PropTypes.string.isRequired,
  selected: PropTypes.bool.isRequired,
  classes: PropTypes.object.isRequired,
};


let styles$9 = function styles(theme) {
  return {
    clockNumber: {
      width: 32,
      height: 32,
      position: 'absolute',
      left: 'calc(50% - 16px)',
      display: 'inline-flex',
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: '50%',
    },
    selected: {
      color: 'white',
    },
  };
};

let ClockNumber$1 = materialUi.withStyles(styles$9, { name: 'MuiPickersClockNumber' })(ClockNumber);

let HourView = (function (_Component) {
  inherits(HourView, _Component);

  function HourView() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, HourView);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = HourView.__proto__ || Object.getPrototypeOf(HourView)).call.apply(_ref, [this].concat(args))), _this), _this.handleChange = function (hours) {
      var updatedDate = _this.props.date.clone().hour(hours);
      _this.props.onChange(updatedDate);
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(HourView, [{
    key: 'render',
    value: function render() {
      var date = this.props.date;


      var value = date.get('hours');
      var ampmValue = Number(date.format('hh'));

      return React__default.createElement(
        Clock$1,
        {
          type: HOURS,
          onChange: this.handleChange,
          value: value
        },
        React__default.createElement(ClockNumber$1, { label: '12', selected: ampmValue === 12, index: 0 }),
        React__default.createElement(ClockNumber$1, { label: '1', selected: ampmValue === 1, index: 1 }),
        React__default.createElement(ClockNumber$1, { label: '2', selected: ampmValue === 2, index: 2 }),
        React__default.createElement(ClockNumber$1, { label: '3', selected: ampmValue === 3, index: 3 }),
        React__default.createElement(ClockNumber$1, { label: '4', selected: ampmValue === 4, index: 4 }),
        React__default.createElement(ClockNumber$1, { label: '5', selected: ampmValue === 5, index: 5 }),
        React__default.createElement(ClockNumber$1, { label: '6', selected: ampmValue === 6, index: 6 }),
        React__default.createElement(ClockNumber$1, { label: '7', selected: ampmValue === 7, index: 7 }),
        React__default.createElement(ClockNumber$1, { label: '8', selected: ampmValue === 8, index: 8 }),
        React__default.createElement(ClockNumber$1, { label: '9', selected: ampmValue === 9, index: 9 }),
        React__default.createElement(ClockNumber$1, { label: '10', selected: ampmValue === 10, index: 10 }),
        React__default.createElement(ClockNumber$1, { label: '11', selected: ampmValue === 11, index: 11 })
      );
    }
  }]);
  return HourView;
}(React.Component));

HourView.propTypes = {
  date: PropTypes.object.isRequired,
  onChange: PropTypes.func.isRequired,
};

let MinutesView = (function (_Component) {
  inherits(MinutesView, _Component);

  function MinutesView() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, MinutesView);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = MinutesView.__proto__ || Object.getPrototypeOf(MinutesView)).call.apply(_ref, [this].concat(args))), _this), _this.handleChange = function (minutes) {
      var updatedDate = _this.props.date.clone().minutes(minutes);
      _this.props.onChange(updatedDate);
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(MinutesView, [{
    key: 'render',
    value: function render() {
      var value = this.props.date.get('minutes');

      return React__default.createElement(
        Clock$1,
        {
          type: MINUTES,
          onChange: this.handleChange,
          value: value
        },
        React__default.createElement(ClockNumber$1, { label: '00', selected: value === 0, index: 0 }),
        React__default.createElement(ClockNumber$1, { label: '05', selected: value === 5, index: 1 }),
        React__default.createElement(ClockNumber$1, { label: '10', selected: value === 10, index: 2 }),
        React__default.createElement(ClockNumber$1, { label: '15', selected: value === 15, index: 3 }),
        React__default.createElement(ClockNumber$1, { label: '20', selected: value === 20, index: 4 }),
        React__default.createElement(ClockNumber$1, { label: '25', selected: value === 25, index: 5 }),
        React__default.createElement(ClockNumber$1, { label: '30', selected: value === 30, index: 6 }),
        React__default.createElement(ClockNumber$1, { label: '35', selected: value === 35, index: 7 }),
        React__default.createElement(ClockNumber$1, { label: '40', selected: value === 40, index: 8 }),
        React__default.createElement(ClockNumber$1, { label: '45', selected: value === 45, index: 9 }),
        React__default.createElement(ClockNumber$1, { label: '50', selected: value === 50, index: 10 }),
        React__default.createElement(ClockNumber$1, { label: '55', selected: value === 55, index: 11 })
      );
    }
  }]);
  return MinutesView;
}(React.Component));

MinutesView.propTypes = {
  date: PropTypes.object.isRequired,
  onChange: PropTypes.func.isRequired,
};

let TimePicker = (function (_Component) {
  inherits(TimePicker, _Component);

  function TimePicker() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, TimePicker);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TimePicker.__proto__ || Object.getPrototypeOf(TimePicker)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      isHourViewShown: true,
      meridiemMode: _this.props.date.format('a')
    }, _this.setMeridiemMode = function (mode) {
      return function () {
        _this.setState({ meridiemMode: mode }, function () {
          return _this.handleChange(_this.props.date);
        });
      };
    }, _this.handleChange = function (time) {
      var meridiemMode = _this.state.meridiemMode;


      if (time.format('a') !== meridiemMode) {
        var hours = meridiemMode === 'am' ? time.hours() - 12 : time.hours() + 12;

        time = time.clone().hours(hours);
      }

      _this.props.onChange(time);
    }, _this.openMinutesView = function () {
      _this.setState({ isHourViewShown: false });
    }, _this.openHourView = function () {
      _this.setState({ isHourViewShown: true });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(TimePicker, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          classes = _props.classes,
          date = _props.date;
      var _state = this.state,
          isHourViewShown = _state.isHourViewShown,
          meridiemMode = _state.meridiemMode;


      return React__default.createElement(
        'div',
        { className: classes.container },
        React__default.createElement(
          materialUi.Toolbar,
          { className: classes.toolbar },
          React__default.createElement(ToolbarButton$1, {
            type: 'display3',
            onClick: this.openHourView,
            selected: isHourViewShown,
            label: date.format('hh')
          }),
          React__default.createElement(ToolbarButton$1, {
            type: 'display3',
            label: ':',
            selected: false,
            className: classes.separator
          }),
          React__default.createElement(ToolbarButton$1, {
            type: 'display3',
            onClick: this.openMinutesView,
            selected: !isHourViewShown,
            label: date.format('mm')
          }),
          React__default.createElement(
            'div',
            { className: classes.ampmSelection },
            React__default.createElement(ToolbarButton$1, {
              className: classes.ampmLabel,
              selected: meridiemMode === 'am',
              type: 'subheading',
              label: 'AM',
              onClick: this.setMeridiemMode('am')
            }),
            React__default.createElement(ToolbarButton$1, {
              className: classes.ampmLabel,
              selected: meridiemMode === 'pm',
              type: 'subheading',
              label: 'PM',
              onClick: this.setMeridiemMode('pm')
            })
          )
        ),
        isHourViewShown ? React__default.createElement(HourView, {
          date: date,
          onChange: this.handleChange
        }) : React__default.createElement(MinutesView, {
          date: date,
          onChange: this.handleChange
        })
      );
    }
  }]);
  return TimePicker;
}(React.Component));

TimePicker.propTypes = {
  date: PropTypes.object.isRequired,
  onChange: PropTypes.func.isRequired,
  classes: PropTypes.object.isRequired,
};


let styles$6 = function styles(theme) {
  let globalStyles = pickerStyles(theme);

  return _extends({}, globalStyles, {
    toolbar: _extends({}, globalStyles.toolbar, {
      flexDirection: 'row',
      alignItems: 'center',
      paddingLeft: 50,
    }),
    separator: {
      margin: '0 2px 0 4px',
      cursor: 'default',
    },
    ampmSelection: {
      marginLeft: 20,
      marginRight: -20,
    },
    ampmLabel: {
      fontSize: 18,
    },
  });
};

let TimePicker$1 = materialUi.withStyles(styles$6, { name: 'MuiPickersTimePicker' })(TimePicker);

let TimePickerModal = (function (_PureComponent) {
  inherits(TimePickerModal, _PureComponent);

  function TimePickerModal() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, TimePickerModal);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TimePickerModal.__proto__ || Object.getPrototypeOf(TimePickerModal)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      open: false,
      time: hooks(_this.props.value)
    }, _this.togglePicker = function () {
      _this.setState({ open: !_this.state.open });
    }, _this.handleChange = function (time) {
      _this.setState({ time: time }, function () {
        if (_this.props.autoOk) {
          _this.handleAccept();
        }
      });
    }, _this.handleAccept = function () {
      _this.props.onChange(_this.state.time);
      _this.togglePicker(); // close
    }, _this.handleDismiss = function () {
      _this.setState({
        time: hooks(_this.props.value)
      });

      _this.togglePicker();
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(TimePickerModal, [{
    key: 'render',
    value: function render() {
      var time = this.state.time;
      var _props = this.props,
          value = _props.value,
          format = _props.format,
          autoOk = _props.autoOk,
          onChange = _props.onChange,
          other = objectWithoutProperties(_props, ['value', 'format', 'autoOk', 'onChange']);


      return React__default.createElement(
        'span',
        null,
        React__default.createElement(DateTextField, _extends({
          value: value,
          format: format,
          onClick: this.togglePicker
        }, other)),
        React__default.createElement(
          ModalDialog$1,
          {
            open: this.state.open,
            onAccept: this.handleAccept,
            onDismiss: this.handleDismiss
          },
          React__default.createElement(TimePicker$1, {
            date: time,
            onChange: this.handleChange
          })
        )
      );
    }
  }]);
  return TimePickerModal;
}(React.PureComponent));

TimePickerModal.propTypes = {
  value: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),
  format: PropTypes.string,
  onChange: PropTypes.func.isRequired,
  autoOk: PropTypes.bool,
};
TimePickerModal.defaultProps = {
  value: null,
  format: 'hh:mm A',
  autoOk: false,
};

exports.DatePicker = DatePickerModal;
exports.TimePicker = TimePickerModal;
// # sourceMappingURL=material-ui-pickers.cjs.js.map
